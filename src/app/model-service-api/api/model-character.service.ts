/**
 * EveKit Model API Server
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { CalendarEventAttendee } from '../model/calendarEventAttendee';
import { CharacterContactNotification } from '../model/characterContactNotification';
import { CharacterFleet } from '../model/characterFleet';
import { CharacterLocation } from '../model/characterLocation';
import { CharacterMailMessage } from '../model/characterMailMessage';
import { CharacterMedal } from '../model/characterMedal';
import { CharacterMedalGraphic } from '../model/characterMedalGraphic';
import { CharacterNotification } from '../model/characterNotification';
import { CharacterOnline } from '../model/characterOnline';
import { CharacterRole } from '../model/characterRole';
import { CharacterSheet } from '../model/characterSheet';
import { CharacterSheetAttributes } from '../model/characterSheetAttributes';
import { CharacterSheetClone } from '../model/characterSheetClone';
import { CharacterSheetJump } from '../model/characterSheetJump';
import { CharacterSheetSkillPoints } from '../model/characterSheetSkillPoints';
import { CharacterShip } from '../model/characterShip';
import { CharacterSkill } from '../model/characterSkill';
import { CharacterTitle } from '../model/characterTitle';
import { ChatChannel } from '../model/chatChannel';
import { ChatChannelMember } from '../model/chatChannelMember';
import { Fitting } from '../model/fitting';
import { FittingItem } from '../model/fittingItem';
import { FleetInfo } from '../model/fleetInfo';
import { FleetMember } from '../model/fleetMember';
import { FleetSquad } from '../model/fleetSquad';
import { FleetWing } from '../model/fleetWing';
import { Implant } from '../model/implant';
import { JumpClone } from '../model/jumpClone';
import { JumpCloneImplant } from '../model/jumpCloneImplant';
import { LoyaltyPoints } from '../model/loyaltyPoints';
import { MailLabel } from '../model/mailLabel';
import { MailingList } from '../model/mailingList';
import { MiningLedger } from '../model/miningLedger';
import { Opportunity } from '../model/opportunity';
import { PlanetaryColony } from '../model/planetaryColony';
import { PlanetaryLink } from '../model/planetaryLink';
import { PlanetaryPin } from '../model/planetaryPin';
import { PlanetaryRoute } from '../model/planetaryRoute';
import { ResearchAgent } from '../model/researchAgent';
import { ServiceError } from '../model/serviceError';
import { SkillInQueue } from '../model/skillInQueue';
import { UpcomingCalendarEvent } from '../model/upcomingCalendarEvent';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ModelCharacterService {

    protected basePath = 'https://evekit-model.orbital.enterprises//api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Get calendar event attendees
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param eventID Calendar event ID selector
     * @param characterID Attending character ID selector
     * @param response Attendee response selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCalendarEventAttendees(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, eventID?: string, characterID?: string, response?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CalendarEventAttendee>>;
    public getCalendarEventAttendees(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, eventID?: string, characterID?: string, response?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CalendarEventAttendee>>>;
    public getCalendarEventAttendees(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, eventID?: string, characterID?: string, response?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CalendarEventAttendee>>>;
    public getCalendarEventAttendees(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, eventID?: string, characterID?: string, response?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getCalendarEventAttendees.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getCalendarEventAttendees.');
        }








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (eventID !== undefined && eventID !== null) {
            queryParameters = queryParameters.set('eventID', <any>eventID);
        }
        if (characterID !== undefined && characterID !== null) {
            queryParameters = queryParameters.set('characterID', <any>characterID);
        }
        if (response !== undefined && response !== null) {
            queryParameters = queryParameters.set('response', <any>response);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CalendarEventAttendee>>(`${this.basePath}/ws/v1/char/calendar_event_attendees`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get chat channel members
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param channelID Channel ID selector
     * @param category Member category selector
     * @param accessorID Member accessor ID selector
     * @param accessorType Member accessor type selector
     * @param untilWhen Member restriction \&quot;until when\&quot; date selector
     * @param reason Member restriction reason selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getChannelMembers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, channelID?: string, category?: string, accessorID?: string, accessorType?: string, untilWhen?: string, reason?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ChatChannelMember>>;
    public getChannelMembers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, channelID?: string, category?: string, accessorID?: string, accessorType?: string, untilWhen?: string, reason?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ChatChannelMember>>>;
    public getChannelMembers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, channelID?: string, category?: string, accessorID?: string, accessorType?: string, untilWhen?: string, reason?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ChatChannelMember>>>;
    public getChannelMembers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, channelID?: string, category?: string, accessorID?: string, accessorType?: string, untilWhen?: string, reason?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getChannelMembers.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getChannelMembers.');
        }











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (channelID !== undefined && channelID !== null) {
            queryParameters = queryParameters.set('channelID', <any>channelID);
        }
        if (category !== undefined && category !== null) {
            queryParameters = queryParameters.set('category', <any>category);
        }
        if (accessorID !== undefined && accessorID !== null) {
            queryParameters = queryParameters.set('accessorID', <any>accessorID);
        }
        if (accessorType !== undefined && accessorType !== null) {
            queryParameters = queryParameters.set('accessorType', <any>accessorType);
        }
        if (untilWhen !== undefined && untilWhen !== null) {
            queryParameters = queryParameters.set('untilWhen', <any>untilWhen);
        }
        if (reason !== undefined && reason !== null) {
            queryParameters = queryParameters.set('reason', <any>reason);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ChatChannelMember>>(`${this.basePath}/ws/v1/char/channel_member`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character chat channels
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param channelID Channel ID selector
     * @param ownerID Channel owner ID selector
     * @param displayName Channel display name selector
     * @param comparisonKey Channel comparison key selector
     * @param hasPassword Channel has password selector
     * @param motd Channel Message of the Day selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getChannels(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, channelID?: string, ownerID?: string, displayName?: string, comparisonKey?: string, hasPassword?: string, motd?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ChatChannel>>;
    public getChannels(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, channelID?: string, ownerID?: string, displayName?: string, comparisonKey?: string, hasPassword?: string, motd?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ChatChannel>>>;
    public getChannels(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, channelID?: string, ownerID?: string, displayName?: string, comparisonKey?: string, hasPassword?: string, motd?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ChatChannel>>>;
    public getChannels(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, channelID?: string, ownerID?: string, displayName?: string, comparisonKey?: string, hasPassword?: string, motd?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getChannels.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getChannels.');
        }











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (channelID !== undefined && channelID !== null) {
            queryParameters = queryParameters.set('channelID', <any>channelID);
        }
        if (ownerID !== undefined && ownerID !== null) {
            queryParameters = queryParameters.set('ownerID', <any>ownerID);
        }
        if (displayName !== undefined && displayName !== null) {
            queryParameters = queryParameters.set('displayName', <any>displayName);
        }
        if (comparisonKey !== undefined && comparisonKey !== null) {
            queryParameters = queryParameters.set('comparisonKey', <any>comparisonKey);
        }
        if (hasPassword !== undefined && hasPassword !== null) {
            queryParameters = queryParameters.set('hasPassword', <any>hasPassword);
        }
        if (motd !== undefined && motd !== null) {
            queryParameters = queryParameters.set('motd', <any>motd);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ChatChannel>>(`${this.basePath}/ws/v1/char/channel`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character fleets
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param fleetID Fleet ID selector
     * @param role Fleet role selector
     * @param squadID Fleet squad ID selector
     * @param wingID Fleet wing ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCharacterFleet(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fleetID?: string, role?: string, squadID?: string, wingID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CharacterFleet>>;
    public getCharacterFleet(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fleetID?: string, role?: string, squadID?: string, wingID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CharacterFleet>>>;
    public getCharacterFleet(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fleetID?: string, role?: string, squadID?: string, wingID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CharacterFleet>>>;
    public getCharacterFleet(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fleetID?: string, role?: string, squadID?: string, wingID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getCharacterFleet.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getCharacterFleet.');
        }









        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (fleetID !== undefined && fleetID !== null) {
            queryParameters = queryParameters.set('fleetID', <any>fleetID);
        }
        if (role !== undefined && role !== null) {
            queryParameters = queryParameters.set('role', <any>role);
        }
        if (squadID !== undefined && squadID !== null) {
            queryParameters = queryParameters.set('squadID', <any>squadID);
        }
        if (wingID !== undefined && wingID !== null) {
            queryParameters = queryParameters.set('wingID', <any>wingID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CharacterFleet>>(`${this.basePath}/ws/v1/char/char_fleet`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character sheet attributes
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param intelligence Intelligence selector
     * @param memory Memory selector
     * @param charisma Charisma selector
     * @param perception Perception selector
     * @param willpower Willpower selector
     * @param lastRemapDate Last remap date selector
     * @param accruedRemapCooldownDate Accrued remap cooldown date selector
     * @param bonusRemaps Bonus remaps selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCharacterSheetAttributes(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, intelligence?: string, memory?: string, charisma?: string, perception?: string, willpower?: string, lastRemapDate?: string, accruedRemapCooldownDate?: string, bonusRemaps?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CharacterSheetAttributes>>;
    public getCharacterSheetAttributes(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, intelligence?: string, memory?: string, charisma?: string, perception?: string, willpower?: string, lastRemapDate?: string, accruedRemapCooldownDate?: string, bonusRemaps?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CharacterSheetAttributes>>>;
    public getCharacterSheetAttributes(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, intelligence?: string, memory?: string, charisma?: string, perception?: string, willpower?: string, lastRemapDate?: string, accruedRemapCooldownDate?: string, bonusRemaps?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CharacterSheetAttributes>>>;
    public getCharacterSheetAttributes(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, intelligence?: string, memory?: string, charisma?: string, perception?: string, willpower?: string, lastRemapDate?: string, accruedRemapCooldownDate?: string, bonusRemaps?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getCharacterSheetAttributes.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getCharacterSheetAttributes.');
        }













        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (intelligence !== undefined && intelligence !== null) {
            queryParameters = queryParameters.set('intelligence', <any>intelligence);
        }
        if (memory !== undefined && memory !== null) {
            queryParameters = queryParameters.set('memory', <any>memory);
        }
        if (charisma !== undefined && charisma !== null) {
            queryParameters = queryParameters.set('charisma', <any>charisma);
        }
        if (perception !== undefined && perception !== null) {
            queryParameters = queryParameters.set('perception', <any>perception);
        }
        if (willpower !== undefined && willpower !== null) {
            queryParameters = queryParameters.set('willpower', <any>willpower);
        }
        if (lastRemapDate !== undefined && lastRemapDate !== null) {
            queryParameters = queryParameters.set('lastRemapDate', <any>lastRemapDate);
        }
        if (accruedRemapCooldownDate !== undefined && accruedRemapCooldownDate !== null) {
            queryParameters = queryParameters.set('accruedRemapCooldownDate', <any>accruedRemapCooldownDate);
        }
        if (bonusRemaps !== undefined && bonusRemaps !== null) {
            queryParameters = queryParameters.set('bonusRemaps', <any>bonusRemaps);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CharacterSheetAttributes>>(`${this.basePath}/ws/v1/char/sheet_attributes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character sheet
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param characterID Character ID selector
     * @param name Name selector
     * @param corporationID Corporation ID selector
     * @param raceID Race selector
     * @param doB Date of birth selector
     * @param bloodlineID Bloodline ID selector
     * @param ancestryID Ancestry ID selector
     * @param gender Gender selector
     * @param allianceID Alliance ID selector
     * @param factionID Faction ID selector
     * @param description Description selector
     * @param securityStatus Security status selector
     * @param title Title selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCharacterSheets(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, name?: string, corporationID?: string, raceID?: string, doB?: string, bloodlineID?: string, ancestryID?: string, gender?: string, allianceID?: string, factionID?: string, description?: string, securityStatus?: string, title?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CharacterSheet>>;
    public getCharacterSheets(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, name?: string, corporationID?: string, raceID?: string, doB?: string, bloodlineID?: string, ancestryID?: string, gender?: string, allianceID?: string, factionID?: string, description?: string, securityStatus?: string, title?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CharacterSheet>>>;
    public getCharacterSheets(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, name?: string, corporationID?: string, raceID?: string, doB?: string, bloodlineID?: string, ancestryID?: string, gender?: string, allianceID?: string, factionID?: string, description?: string, securityStatus?: string, title?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CharacterSheet>>>;
    public getCharacterSheets(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, name?: string, corporationID?: string, raceID?: string, doB?: string, bloodlineID?: string, ancestryID?: string, gender?: string, allianceID?: string, factionID?: string, description?: string, securityStatus?: string, title?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getCharacterSheets.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getCharacterSheets.');
        }


















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (characterID !== undefined && characterID !== null) {
            queryParameters = queryParameters.set('characterID', <any>characterID);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (corporationID !== undefined && corporationID !== null) {
            queryParameters = queryParameters.set('corporationID', <any>corporationID);
        }
        if (raceID !== undefined && raceID !== null) {
            queryParameters = queryParameters.set('raceID', <any>raceID);
        }
        if (doB !== undefined && doB !== null) {
            queryParameters = queryParameters.set('doB', <any>doB);
        }
        if (bloodlineID !== undefined && bloodlineID !== null) {
            queryParameters = queryParameters.set('bloodlineID', <any>bloodlineID);
        }
        if (ancestryID !== undefined && ancestryID !== null) {
            queryParameters = queryParameters.set('ancestryID', <any>ancestryID);
        }
        if (gender !== undefined && gender !== null) {
            queryParameters = queryParameters.set('gender', <any>gender);
        }
        if (allianceID !== undefined && allianceID !== null) {
            queryParameters = queryParameters.set('allianceID', <any>allianceID);
        }
        if (factionID !== undefined && factionID !== null) {
            queryParameters = queryParameters.set('factionID', <any>factionID);
        }
        if (description !== undefined && description !== null) {
            queryParameters = queryParameters.set('description', <any>description);
        }
        if (securityStatus !== undefined && securityStatus !== null) {
            queryParameters = queryParameters.set('securityStatus', <any>securityStatus);
        }
        if (title !== undefined && title !== null) {
            queryParameters = queryParameters.set('title', <any>title);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CharacterSheet>>(`${this.basePath}/ws/v1/char/sheet`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character clone jump timers
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param cloneJumpDate Clone jump date selector
     * @param homeStationID Home station ID selector
     * @param homeStationType Home station type selector
     * @param lastStationChangeDate Last station change date selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCloneJumpTimers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, cloneJumpDate?: string, homeStationID?: string, homeStationType?: string, lastStationChangeDate?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CharacterSheetClone>>;
    public getCloneJumpTimers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, cloneJumpDate?: string, homeStationID?: string, homeStationType?: string, lastStationChangeDate?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CharacterSheetClone>>>;
    public getCloneJumpTimers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, cloneJumpDate?: string, homeStationID?: string, homeStationType?: string, lastStationChangeDate?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CharacterSheetClone>>>;
    public getCloneJumpTimers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, cloneJumpDate?: string, homeStationID?: string, homeStationType?: string, lastStationChangeDate?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getCloneJumpTimers.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getCloneJumpTimers.');
        }









        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (cloneJumpDate !== undefined && cloneJumpDate !== null) {
            queryParameters = queryParameters.set('cloneJumpDate', <any>cloneJumpDate);
        }
        if (homeStationID !== undefined && homeStationID !== null) {
            queryParameters = queryParameters.set('homeStationID', <any>homeStationID);
        }
        if (homeStationType !== undefined && homeStationType !== null) {
            queryParameters = queryParameters.set('homeStationType', <any>homeStationType);
        }
        if (lastStationChangeDate !== undefined && lastStationChangeDate !== null) {
            queryParameters = queryParameters.set('lastStationChangeDate', <any>lastStationChangeDate);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CharacterSheetClone>>(`${this.basePath}/ws/v1/char/clone_jump_timer`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character contact notifications
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param notificationID Notification ID selector
     * @param senderID Contact notification sender ID selector
     * @param sentDate Contact notification send date selector
     * @param standingLevel Contact notification standing level selector
     * @param messageData Contact notification message data selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getContactNotifications(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, notificationID?: string, senderID?: string, sentDate?: string, standingLevel?: string, messageData?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CharacterContactNotification>>;
    public getContactNotifications(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, notificationID?: string, senderID?: string, sentDate?: string, standingLevel?: string, messageData?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CharacterContactNotification>>>;
    public getContactNotifications(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, notificationID?: string, senderID?: string, sentDate?: string, standingLevel?: string, messageData?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CharacterContactNotification>>>;
    public getContactNotifications(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, notificationID?: string, senderID?: string, sentDate?: string, standingLevel?: string, messageData?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getContactNotifications.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getContactNotifications.');
        }










        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (notificationID !== undefined && notificationID !== null) {
            queryParameters = queryParameters.set('notificationID', <any>notificationID);
        }
        if (senderID !== undefined && senderID !== null) {
            queryParameters = queryParameters.set('senderID', <any>senderID);
        }
        if (sentDate !== undefined && sentDate !== null) {
            queryParameters = queryParameters.set('sentDate', <any>sentDate);
        }
        if (standingLevel !== undefined && standingLevel !== null) {
            queryParameters = queryParameters.set('standingLevel', <any>standingLevel);
        }
        if (messageData !== undefined && messageData !== null) {
            queryParameters = queryParameters.set('messageData', <any>messageData);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CharacterContactNotification>>(`${this.basePath}/ws/v1/char/contact_notification`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character ship fitting items
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param fittingID Ship fitting item fitting ID selector
     * @param typeID Ship fitting item type ID selector
     * @param flag Ship fitting item flag selector
     * @param quantity Ship fitting item quantity selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFittingItems(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fittingID?: string, typeID?: string, flag?: string, quantity?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<FittingItem>>;
    public getFittingItems(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fittingID?: string, typeID?: string, flag?: string, quantity?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FittingItem>>>;
    public getFittingItems(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fittingID?: string, typeID?: string, flag?: string, quantity?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FittingItem>>>;
    public getFittingItems(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fittingID?: string, typeID?: string, flag?: string, quantity?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getFittingItems.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getFittingItems.');
        }









        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (fittingID !== undefined && fittingID !== null) {
            queryParameters = queryParameters.set('fittingID', <any>fittingID);
        }
        if (typeID !== undefined && typeID !== null) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (flag !== undefined && flag !== null) {
            queryParameters = queryParameters.set('flag', <any>flag);
        }
        if (quantity !== undefined && quantity !== null) {
            queryParameters = queryParameters.set('quantity', <any>quantity);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<FittingItem>>(`${this.basePath}/ws/v1/char/fitting_items`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character ship fittings
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param fittingID Ship fitting ID selector
     * @param name Ship fitting name selector
     * @param description Ship fitting description selector
     * @param shipTypeID Ship fitting ship type ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFittings(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fittingID?: string, name?: string, description?: string, shipTypeID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Fitting>>;
    public getFittings(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fittingID?: string, name?: string, description?: string, shipTypeID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Fitting>>>;
    public getFittings(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fittingID?: string, name?: string, description?: string, shipTypeID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Fitting>>>;
    public getFittings(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fittingID?: string, name?: string, description?: string, shipTypeID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getFittings.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getFittings.');
        }









        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (fittingID !== undefined && fittingID !== null) {
            queryParameters = queryParameters.set('fittingID', <any>fittingID);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (description !== undefined && description !== null) {
            queryParameters = queryParameters.set('description', <any>description);
        }
        if (shipTypeID !== undefined && shipTypeID !== null) {
            queryParameters = queryParameters.set('shipTypeID', <any>shipTypeID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Fitting>>(`${this.basePath}/ws/v1/char/fittings`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get fleet info
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param fleetID Fleet ID selector
     * @param isFreeMove Fleet &#39;is free move&#39; selector
     * @param isRegistered Fleet &#39;is registered&#39; selector
     * @param isVoiceEnabled Fleet &#39;is voice enabled&#39; selector
     * @param motd Fleet message of the day selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFleetInfo(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fleetID?: string, isFreeMove?: string, isRegistered?: string, isVoiceEnabled?: string, motd?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<FleetInfo>>;
    public getFleetInfo(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fleetID?: string, isFreeMove?: string, isRegistered?: string, isVoiceEnabled?: string, motd?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FleetInfo>>>;
    public getFleetInfo(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fleetID?: string, isFreeMove?: string, isRegistered?: string, isVoiceEnabled?: string, motd?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FleetInfo>>>;
    public getFleetInfo(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fleetID?: string, isFreeMove?: string, isRegistered?: string, isVoiceEnabled?: string, motd?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getFleetInfo.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getFleetInfo.');
        }










        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (fleetID !== undefined && fleetID !== null) {
            queryParameters = queryParameters.set('fleetID', <any>fleetID);
        }
        if (isFreeMove !== undefined && isFreeMove !== null) {
            queryParameters = queryParameters.set('isFreeMove', <any>isFreeMove);
        }
        if (isRegistered !== undefined && isRegistered !== null) {
            queryParameters = queryParameters.set('isRegistered', <any>isRegistered);
        }
        if (isVoiceEnabled !== undefined && isVoiceEnabled !== null) {
            queryParameters = queryParameters.set('isVoiceEnabled', <any>isVoiceEnabled);
        }
        if (motd !== undefined && motd !== null) {
            queryParameters = queryParameters.set('motd', <any>motd);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<FleetInfo>>(`${this.basePath}/ws/v1/char/fleet_info`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get fleet membership info
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param fleetID Fleet member fleet ID selector
     * @param characterID Fleet member character ID selector
     * @param joinTime Fleet member join time selector
     * @param role Fleet member role selector
     * @param roleName Fleet member role name selector
     * @param shipTypeID Fleet member ship type ID selector
     * @param solarSystemID Fleet member solar system ID selector
     * @param squadID Fleet member squad ID selector
     * @param stationID Fleet member station ID selector
     * @param takesFleetWarp Fleet member &#39;takes fleet warp&#39; selector
     * @param wingID Fleet member wing ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFleetMembers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fleetID?: string, characterID?: string, joinTime?: string, role?: string, roleName?: string, shipTypeID?: string, solarSystemID?: string, squadID?: string, stationID?: string, takesFleetWarp?: string, wingID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<FleetMember>>;
    public getFleetMembers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fleetID?: string, characterID?: string, joinTime?: string, role?: string, roleName?: string, shipTypeID?: string, solarSystemID?: string, squadID?: string, stationID?: string, takesFleetWarp?: string, wingID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FleetMember>>>;
    public getFleetMembers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fleetID?: string, characterID?: string, joinTime?: string, role?: string, roleName?: string, shipTypeID?: string, solarSystemID?: string, squadID?: string, stationID?: string, takesFleetWarp?: string, wingID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FleetMember>>>;
    public getFleetMembers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fleetID?: string, characterID?: string, joinTime?: string, role?: string, roleName?: string, shipTypeID?: string, solarSystemID?: string, squadID?: string, stationID?: string, takesFleetWarp?: string, wingID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getFleetMembers.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getFleetMembers.');
        }
















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (fleetID !== undefined && fleetID !== null) {
            queryParameters = queryParameters.set('fleetID', <any>fleetID);
        }
        if (characterID !== undefined && characterID !== null) {
            queryParameters = queryParameters.set('characterID', <any>characterID);
        }
        if (joinTime !== undefined && joinTime !== null) {
            queryParameters = queryParameters.set('joinTime', <any>joinTime);
        }
        if (role !== undefined && role !== null) {
            queryParameters = queryParameters.set('role', <any>role);
        }
        if (roleName !== undefined && roleName !== null) {
            queryParameters = queryParameters.set('roleName', <any>roleName);
        }
        if (shipTypeID !== undefined && shipTypeID !== null) {
            queryParameters = queryParameters.set('shipTypeID', <any>shipTypeID);
        }
        if (solarSystemID !== undefined && solarSystemID !== null) {
            queryParameters = queryParameters.set('solarSystemID', <any>solarSystemID);
        }
        if (squadID !== undefined && squadID !== null) {
            queryParameters = queryParameters.set('squadID', <any>squadID);
        }
        if (stationID !== undefined && stationID !== null) {
            queryParameters = queryParameters.set('stationID', <any>stationID);
        }
        if (takesFleetWarp !== undefined && takesFleetWarp !== null) {
            queryParameters = queryParameters.set('takesFleetWarp', <any>takesFleetWarp);
        }
        if (wingID !== undefined && wingID !== null) {
            queryParameters = queryParameters.set('wingID', <any>wingID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<FleetMember>>(`${this.basePath}/ws/v1/char/fleet_members`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get fleet squad info
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param fleetID Fleet squad fleet ID selector
     * @param wingID Fleet squad wing ID selector
     * @param squadID Fleet squad ID selector
     * @param name Fleet squad name selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFleetSquads(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fleetID?: string, wingID?: string, squadID?: string, name?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<FleetSquad>>;
    public getFleetSquads(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fleetID?: string, wingID?: string, squadID?: string, name?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FleetSquad>>>;
    public getFleetSquads(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fleetID?: string, wingID?: string, squadID?: string, name?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FleetSquad>>>;
    public getFleetSquads(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fleetID?: string, wingID?: string, squadID?: string, name?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getFleetSquads.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getFleetSquads.');
        }









        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (fleetID !== undefined && fleetID !== null) {
            queryParameters = queryParameters.set('fleetID', <any>fleetID);
        }
        if (wingID !== undefined && wingID !== null) {
            queryParameters = queryParameters.set('wingID', <any>wingID);
        }
        if (squadID !== undefined && squadID !== null) {
            queryParameters = queryParameters.set('squadID', <any>squadID);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<FleetSquad>>(`${this.basePath}/ws/v1/char/fleet_squads`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get fleet wing info
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param fleetID Fleet wing fleet ID selector
     * @param wingID Fleet wing ID selector
     * @param name Fleet wing name selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFleetWings(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fleetID?: string, wingID?: string, name?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<FleetWing>>;
    public getFleetWings(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fleetID?: string, wingID?: string, name?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FleetWing>>>;
    public getFleetWings(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fleetID?: string, wingID?: string, name?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FleetWing>>>;
    public getFleetWings(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, fleetID?: string, wingID?: string, name?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getFleetWings.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getFleetWings.');
        }








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (fleetID !== undefined && fleetID !== null) {
            queryParameters = queryParameters.set('fleetID', <any>fleetID);
        }
        if (wingID !== undefined && wingID !== null) {
            queryParameters = queryParameters.set('wingID', <any>wingID);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<FleetWing>>(`${this.basePath}/ws/v1/char/fleet_wings`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character implants
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param typeID Implant type ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getImplants(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, typeID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Implant>>;
    public getImplants(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, typeID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Implant>>>;
    public getImplants(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, typeID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Implant>>>;
    public getImplants(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, typeID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getImplants.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getImplants.');
        }






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (typeID !== undefined && typeID !== null) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Implant>>(`${this.basePath}/ws/v1/char/implant`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character jump clone implants
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param jumpCloneID Jump clone ID selector
     * @param typeID Implant type ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getJumpCloneImplants(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, jumpCloneID?: string, typeID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<JumpCloneImplant>>;
    public getJumpCloneImplants(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, jumpCloneID?: string, typeID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<JumpCloneImplant>>>;
    public getJumpCloneImplants(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, jumpCloneID?: string, typeID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<JumpCloneImplant>>>;
    public getJumpCloneImplants(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, jumpCloneID?: string, typeID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getJumpCloneImplants.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getJumpCloneImplants.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (jumpCloneID !== undefined && jumpCloneID !== null) {
            queryParameters = queryParameters.set('jumpCloneID', <any>jumpCloneID);
        }
        if (typeID !== undefined && typeID !== null) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<JumpCloneImplant>>(`${this.basePath}/ws/v1/char/jump_clone_implant`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character jump clones
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param jumpCloneID Jump clone ID selector
     * @param locationID Jump clone location ID selector
     * @param cloneName Clone name selector selector
     * @param locationType Location type selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getJumpClones(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, jumpCloneID?: string, locationID?: string, cloneName?: string, locationType?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<JumpClone>>;
    public getJumpClones(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, jumpCloneID?: string, locationID?: string, cloneName?: string, locationType?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<JumpClone>>>;
    public getJumpClones(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, jumpCloneID?: string, locationID?: string, cloneName?: string, locationType?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<JumpClone>>>;
    public getJumpClones(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, jumpCloneID?: string, locationID?: string, cloneName?: string, locationType?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getJumpClones.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getJumpClones.');
        }









        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (jumpCloneID !== undefined && jumpCloneID !== null) {
            queryParameters = queryParameters.set('jumpCloneID', <any>jumpCloneID);
        }
        if (locationID !== undefined && locationID !== null) {
            queryParameters = queryParameters.set('locationID', <any>locationID);
        }
        if (cloneName !== undefined && cloneName !== null) {
            queryParameters = queryParameters.set('cloneName', <any>cloneName);
        }
        if (locationType !== undefined && locationType !== null) {
            queryParameters = queryParameters.set('locationType', <any>locationType);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<JumpClone>>(`${this.basePath}/ws/v1/char/jump_clone`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character jump timers
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param jumpActivation Jump activation selector
     * @param jumpFatigue Jump fatigue selector
     * @param jumpLastUpdate Jump last update time selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getJumpTimers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, jumpActivation?: string, jumpFatigue?: string, jumpLastUpdate?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CharacterSheetJump>>;
    public getJumpTimers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, jumpActivation?: string, jumpFatigue?: string, jumpLastUpdate?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CharacterSheetJump>>>;
    public getJumpTimers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, jumpActivation?: string, jumpFatigue?: string, jumpLastUpdate?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CharacterSheetJump>>>;
    public getJumpTimers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, jumpActivation?: string, jumpFatigue?: string, jumpLastUpdate?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getJumpTimers.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getJumpTimers.');
        }








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (jumpActivation !== undefined && jumpActivation !== null) {
            queryParameters = queryParameters.set('jumpActivation', <any>jumpActivation);
        }
        if (jumpFatigue !== undefined && jumpFatigue !== null) {
            queryParameters = queryParameters.set('jumpFatigue', <any>jumpFatigue);
        }
        if (jumpLastUpdate !== undefined && jumpLastUpdate !== null) {
            queryParameters = queryParameters.set('jumpLastUpdate', <any>jumpLastUpdate);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CharacterSheetJump>>(`${this.basePath}/ws/v1/char/jump_timer`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character location
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param solarSystemID Solar system ID selector
     * @param stationID Station ID selector
     * @param structureID Structure ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLocation(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, solarSystemID?: string, stationID?: string, structureID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CharacterLocation>>;
    public getLocation(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, solarSystemID?: string, stationID?: string, structureID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CharacterLocation>>>;
    public getLocation(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, solarSystemID?: string, stationID?: string, structureID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CharacterLocation>>>;
    public getLocation(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, solarSystemID?: string, stationID?: string, structureID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getLocation.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getLocation.');
        }








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (solarSystemID !== undefined && solarSystemID !== null) {
            queryParameters = queryParameters.set('solarSystemID', <any>solarSystemID);
        }
        if (stationID !== undefined && stationID !== null) {
            queryParameters = queryParameters.set('stationID', <any>stationID);
        }
        if (structureID !== undefined && structureID !== null) {
            queryParameters = queryParameters.set('structureID', <any>structureID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CharacterLocation>>(`${this.basePath}/ws/v1/char/location`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character loyalty points
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param corporationID Corporation ID selector
     * @param loyaltyPoints Loyalty points selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLoyaltyPoints(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, corporationID?: string, loyaltyPoints?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<LoyaltyPoints>>;
    public getLoyaltyPoints(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, corporationID?: string, loyaltyPoints?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<LoyaltyPoints>>>;
    public getLoyaltyPoints(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, corporationID?: string, loyaltyPoints?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<LoyaltyPoints>>>;
    public getLoyaltyPoints(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, corporationID?: string, loyaltyPoints?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getLoyaltyPoints.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getLoyaltyPoints.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (corporationID !== undefined && corporationID !== null) {
            queryParameters = queryParameters.set('corporationID', <any>corporationID);
        }
        if (loyaltyPoints !== undefined && loyaltyPoints !== null) {
            queryParameters = queryParameters.set('loyaltyPoints', <any>loyaltyPoints);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<LoyaltyPoints>>(`${this.basePath}/ws/v1/char/loyalty_points`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character mail labels
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param labelID Mail label ID selector
     * @param unreadCount Mail label unread count selector
     * @param name Mail label name selector
     * @param color Mail label color selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMailLabels(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, labelID?: string, unreadCount?: string, name?: string, color?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MailLabel>>;
    public getMailLabels(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, labelID?: string, unreadCount?: string, name?: string, color?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MailLabel>>>;
    public getMailLabels(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, labelID?: string, unreadCount?: string, name?: string, color?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MailLabel>>>;
    public getMailLabels(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, labelID?: string, unreadCount?: string, name?: string, color?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getMailLabels.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getMailLabels.');
        }









        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (labelID !== undefined && labelID !== null) {
            queryParameters = queryParameters.set('labelID', <any>labelID);
        }
        if (unreadCount !== undefined && unreadCount !== null) {
            queryParameters = queryParameters.set('unreadCount', <any>unreadCount);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (color !== undefined && color !== null) {
            queryParameters = queryParameters.set('color', <any>color);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MailLabel>>(`${this.basePath}/ws/v1/char/mail_label`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character mail messages
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param messageID Message ID selector
     * @param senderID Message sender ID selector
     * @param sentDate Message send date selector
     * @param title Message title selector
     * @param msgRead Message read selector
     * @param labelID Message label ID selector
     * @param recipientType Message recipient type selector
     * @param recipientID Message recipient ID selector
     * @param body Message body selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMailMessages(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, messageID?: string, senderID?: string, sentDate?: string, title?: string, msgRead?: string, labelID?: string, recipientType?: string, recipientID?: string, body?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CharacterMailMessage>>;
    public getMailMessages(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, messageID?: string, senderID?: string, sentDate?: string, title?: string, msgRead?: string, labelID?: string, recipientType?: string, recipientID?: string, body?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CharacterMailMessage>>>;
    public getMailMessages(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, messageID?: string, senderID?: string, sentDate?: string, title?: string, msgRead?: string, labelID?: string, recipientType?: string, recipientID?: string, body?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CharacterMailMessage>>>;
    public getMailMessages(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, messageID?: string, senderID?: string, sentDate?: string, title?: string, msgRead?: string, labelID?: string, recipientType?: string, recipientID?: string, body?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getMailMessages.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getMailMessages.');
        }














        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (messageID !== undefined && messageID !== null) {
            queryParameters = queryParameters.set('messageID', <any>messageID);
        }
        if (senderID !== undefined && senderID !== null) {
            queryParameters = queryParameters.set('senderID', <any>senderID);
        }
        if (sentDate !== undefined && sentDate !== null) {
            queryParameters = queryParameters.set('sentDate', <any>sentDate);
        }
        if (title !== undefined && title !== null) {
            queryParameters = queryParameters.set('title', <any>title);
        }
        if (msgRead !== undefined && msgRead !== null) {
            queryParameters = queryParameters.set('msgRead', <any>msgRead);
        }
        if (labelID !== undefined && labelID !== null) {
            queryParameters = queryParameters.set('labelID', <any>labelID);
        }
        if (recipientType !== undefined && recipientType !== null) {
            queryParameters = queryParameters.set('recipientType', <any>recipientType);
        }
        if (recipientID !== undefined && recipientID !== null) {
            queryParameters = queryParameters.set('recipientID', <any>recipientID);
        }
        if (body !== undefined && body !== null) {
            queryParameters = queryParameters.set('body', <any>body);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CharacterMailMessage>>(`${this.basePath}/ws/v1/char/mail_message`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character mailing lists
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param displayName Mailing list display name selector
     * @param listID Mailing list ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMailingLists(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, displayName?: string, listID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MailingList>>;
    public getMailingLists(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, displayName?: string, listID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MailingList>>>;
    public getMailingLists(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, displayName?: string, listID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MailingList>>>;
    public getMailingLists(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, displayName?: string, listID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getMailingLists.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getMailingLists.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (displayName !== undefined && displayName !== null) {
            queryParameters = queryParameters.set('displayName', <any>displayName);
        }
        if (listID !== undefined && listID !== null) {
            queryParameters = queryParameters.set('listID', <any>listID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MailingList>>(`${this.basePath}/ws/v1/char/mailing_list`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character medal graphics
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param medalID Medal ID selector
     * @param issued Medal issued selector
     * @param part Medal graphic part selector
     * @param layer Medal graphic layer selector
     * @param graphic Medal graphic name selector
     * @param color Medal graphic color selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMedalGraphics(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, medalID?: string, issued?: string, part?: string, layer?: string, graphic?: string, color?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CharacterMedalGraphic>>;
    public getMedalGraphics(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, medalID?: string, issued?: string, part?: string, layer?: string, graphic?: string, color?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CharacterMedalGraphic>>>;
    public getMedalGraphics(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, medalID?: string, issued?: string, part?: string, layer?: string, graphic?: string, color?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CharacterMedalGraphic>>>;
    public getMedalGraphics(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, medalID?: string, issued?: string, part?: string, layer?: string, graphic?: string, color?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getMedalGraphics.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getMedalGraphics.');
        }











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (medalID !== undefined && medalID !== null) {
            queryParameters = queryParameters.set('medalID', <any>medalID);
        }
        if (issued !== undefined && issued !== null) {
            queryParameters = queryParameters.set('issued', <any>issued);
        }
        if (part !== undefined && part !== null) {
            queryParameters = queryParameters.set('part', <any>part);
        }
        if (layer !== undefined && layer !== null) {
            queryParameters = queryParameters.set('layer', <any>layer);
        }
        if (graphic !== undefined && graphic !== null) {
            queryParameters = queryParameters.set('graphic', <any>graphic);
        }
        if (color !== undefined && color !== null) {
            queryParameters = queryParameters.set('color', <any>color);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CharacterMedalGraphic>>(`${this.basePath}/ws/v1/char/medal_graphic`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character medals
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param description Medal description selector
     * @param medalID Medal ID selector
     * @param title Medal title selector
     * @param corporationID Awarding corporation ID selector
     * @param issued Issue date selector
     * @param issuerID Issuer ID selector
     * @param reason Medal award reason selector
     * @param status Medal status selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMedals(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, description?: string, medalID?: string, title?: string, corporationID?: string, issued?: string, issuerID?: string, reason?: string, status?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CharacterMedal>>;
    public getMedals(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, description?: string, medalID?: string, title?: string, corporationID?: string, issued?: string, issuerID?: string, reason?: string, status?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CharacterMedal>>>;
    public getMedals(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, description?: string, medalID?: string, title?: string, corporationID?: string, issued?: string, issuerID?: string, reason?: string, status?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CharacterMedal>>>;
    public getMedals(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, description?: string, medalID?: string, title?: string, corporationID?: string, issued?: string, issuerID?: string, reason?: string, status?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getMedals.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getMedals.');
        }













        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (description !== undefined && description !== null) {
            queryParameters = queryParameters.set('description', <any>description);
        }
        if (medalID !== undefined && medalID !== null) {
            queryParameters = queryParameters.set('medalID', <any>medalID);
        }
        if (title !== undefined && title !== null) {
            queryParameters = queryParameters.set('title', <any>title);
        }
        if (corporationID !== undefined && corporationID !== null) {
            queryParameters = queryParameters.set('corporationID', <any>corporationID);
        }
        if (issued !== undefined && issued !== null) {
            queryParameters = queryParameters.set('issued', <any>issued);
        }
        if (issuerID !== undefined && issuerID !== null) {
            queryParameters = queryParameters.set('issuerID', <any>issuerID);
        }
        if (reason !== undefined && reason !== null) {
            queryParameters = queryParameters.set('reason', <any>reason);
        }
        if (status !== undefined && status !== null) {
            queryParameters = queryParameters.set('status', <any>status);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CharacterMedal>>(`${this.basePath}/ws/v1/char/medal`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character mining ledger
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param date Date selector
     * @param solarSystemID Solar system ID selector
     * @param typeID Type ID selector
     * @param quantity Quantity selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMiningLedger(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, date?: string, solarSystemID?: string, typeID?: string, quantity?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MiningLedger>>;
    public getMiningLedger(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, date?: string, solarSystemID?: string, typeID?: string, quantity?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MiningLedger>>>;
    public getMiningLedger(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, date?: string, solarSystemID?: string, typeID?: string, quantity?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MiningLedger>>>;
    public getMiningLedger(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, date?: string, solarSystemID?: string, typeID?: string, quantity?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getMiningLedger.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getMiningLedger.');
        }









        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (date !== undefined && date !== null) {
            queryParameters = queryParameters.set('date', <any>date);
        }
        if (solarSystemID !== undefined && solarSystemID !== null) {
            queryParameters = queryParameters.set('solarSystemID', <any>solarSystemID);
        }
        if (typeID !== undefined && typeID !== null) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (quantity !== undefined && quantity !== null) {
            queryParameters = queryParameters.set('quantity', <any>quantity);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MiningLedger>>(`${this.basePath}/ws/v1/char/mining_ledger`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character notifications (not bodies)
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param notificationID Notification ID selector
     * @param type Notification type selector
     * @param senderID Notification sender ID selector
     * @param senderType Notification sender type selector
     * @param sentDate Notification send date selector
     * @param msgRead Notification read selector
     * @param text Notification text selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getNotifications(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, notificationID?: string, type?: string, senderID?: string, senderType?: string, sentDate?: string, msgRead?: string, text?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CharacterNotification>>;
    public getNotifications(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, notificationID?: string, type?: string, senderID?: string, senderType?: string, sentDate?: string, msgRead?: string, text?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CharacterNotification>>>;
    public getNotifications(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, notificationID?: string, type?: string, senderID?: string, senderType?: string, sentDate?: string, msgRead?: string, text?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CharacterNotification>>>;
    public getNotifications(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, notificationID?: string, type?: string, senderID?: string, senderType?: string, sentDate?: string, msgRead?: string, text?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getNotifications.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getNotifications.');
        }












        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (notificationID !== undefined && notificationID !== null) {
            queryParameters = queryParameters.set('notificationID', <any>notificationID);
        }
        if (type !== undefined && type !== null) {
            queryParameters = queryParameters.set('type', <any>type);
        }
        if (senderID !== undefined && senderID !== null) {
            queryParameters = queryParameters.set('senderID', <any>senderID);
        }
        if (senderType !== undefined && senderType !== null) {
            queryParameters = queryParameters.set('senderType', <any>senderType);
        }
        if (sentDate !== undefined && sentDate !== null) {
            queryParameters = queryParameters.set('sentDate', <any>sentDate);
        }
        if (msgRead !== undefined && msgRead !== null) {
            queryParameters = queryParameters.set('msgRead', <any>msgRead);
        }
        if (text !== undefined && text !== null) {
            queryParameters = queryParameters.set('text', <any>text);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CharacterNotification>>(`${this.basePath}/ws/v1/char/notification`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character online data
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param online Online selector
     * @param lastLogin Last login selector
     * @param lastLogout Last logout selector
     * @param logins Logins selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOnline(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, online?: string, lastLogin?: string, lastLogout?: string, logins?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CharacterOnline>>;
    public getOnline(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, online?: string, lastLogin?: string, lastLogout?: string, logins?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CharacterOnline>>>;
    public getOnline(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, online?: string, lastLogin?: string, lastLogout?: string, logins?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CharacterOnline>>>;
    public getOnline(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, online?: string, lastLogin?: string, lastLogout?: string, logins?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getOnline.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getOnline.');
        }









        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (online !== undefined && online !== null) {
            queryParameters = queryParameters.set('online', <any>online);
        }
        if (lastLogin !== undefined && lastLogin !== null) {
            queryParameters = queryParameters.set('lastLogin', <any>lastLogin);
        }
        if (lastLogout !== undefined && lastLogout !== null) {
            queryParameters = queryParameters.set('lastLogout', <any>lastLogout);
        }
        if (logins !== undefined && logins !== null) {
            queryParameters = queryParameters.set('logins', <any>logins);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CharacterOnline>>(`${this.basePath}/ws/v1/char/online`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get opportunities
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param taskID Opportunity task ID selector
     * @param completedAt Opportunity &#39;completed at&#39; time selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOpportunities(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, taskID?: string, completedAt?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Opportunity>>;
    public getOpportunities(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, taskID?: string, completedAt?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Opportunity>>>;
    public getOpportunities(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, taskID?: string, completedAt?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Opportunity>>>;
    public getOpportunities(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, taskID?: string, completedAt?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getOpportunities.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getOpportunities.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (taskID !== undefined && taskID !== null) {
            queryParameters = queryParameters.set('taskID', <any>taskID);
        }
        if (completedAt !== undefined && completedAt !== null) {
            queryParameters = queryParameters.set('completedAt', <any>completedAt);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Opportunity>>(`${this.basePath}/ws/v1/char/opportunities`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get planetary colonies
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param planetID Planet ID selector
     * @param solarSystemID Solar system ID selector
     * @param planetType Planet type selector
     * @param ownerID Colony owner ID selector
     * @param lastUpdate Colony last update selector
     * @param upgradeLevel Colony upgrade level selector
     * @param numberOfPins Colony number of pins selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPlanetaryColonies(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, planetID?: string, solarSystemID?: string, planetType?: string, ownerID?: string, lastUpdate?: string, upgradeLevel?: string, numberOfPins?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<PlanetaryColony>>;
    public getPlanetaryColonies(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, planetID?: string, solarSystemID?: string, planetType?: string, ownerID?: string, lastUpdate?: string, upgradeLevel?: string, numberOfPins?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PlanetaryColony>>>;
    public getPlanetaryColonies(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, planetID?: string, solarSystemID?: string, planetType?: string, ownerID?: string, lastUpdate?: string, upgradeLevel?: string, numberOfPins?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PlanetaryColony>>>;
    public getPlanetaryColonies(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, planetID?: string, solarSystemID?: string, planetType?: string, ownerID?: string, lastUpdate?: string, upgradeLevel?: string, numberOfPins?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getPlanetaryColonies.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getPlanetaryColonies.');
        }












        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (planetID !== undefined && planetID !== null) {
            queryParameters = queryParameters.set('planetID', <any>planetID);
        }
        if (solarSystemID !== undefined && solarSystemID !== null) {
            queryParameters = queryParameters.set('solarSystemID', <any>solarSystemID);
        }
        if (planetType !== undefined && planetType !== null) {
            queryParameters = queryParameters.set('planetType', <any>planetType);
        }
        if (ownerID !== undefined && ownerID !== null) {
            queryParameters = queryParameters.set('ownerID', <any>ownerID);
        }
        if (lastUpdate !== undefined && lastUpdate !== null) {
            queryParameters = queryParameters.set('lastUpdate', <any>lastUpdate);
        }
        if (upgradeLevel !== undefined && upgradeLevel !== null) {
            queryParameters = queryParameters.set('upgradeLevel', <any>upgradeLevel);
        }
        if (numberOfPins !== undefined && numberOfPins !== null) {
            queryParameters = queryParameters.set('numberOfPins', <any>numberOfPins);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<PlanetaryColony>>(`${this.basePath}/ws/v1/char/planetary_colony`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get planetary links
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param planetID Planet ID selector
     * @param sourcePinID Link source pin ID selector
     * @param destinationPinID Link destination pin ID selector
     * @param linkLevel Link level selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPlanetaryLinks(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, planetID?: string, sourcePinID?: string, destinationPinID?: string, linkLevel?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<PlanetaryLink>>;
    public getPlanetaryLinks(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, planetID?: string, sourcePinID?: string, destinationPinID?: string, linkLevel?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PlanetaryLink>>>;
    public getPlanetaryLinks(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, planetID?: string, sourcePinID?: string, destinationPinID?: string, linkLevel?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PlanetaryLink>>>;
    public getPlanetaryLinks(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, planetID?: string, sourcePinID?: string, destinationPinID?: string, linkLevel?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getPlanetaryLinks.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getPlanetaryLinks.');
        }









        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (planetID !== undefined && planetID !== null) {
            queryParameters = queryParameters.set('planetID', <any>planetID);
        }
        if (sourcePinID !== undefined && sourcePinID !== null) {
            queryParameters = queryParameters.set('sourcePinID', <any>sourcePinID);
        }
        if (destinationPinID !== undefined && destinationPinID !== null) {
            queryParameters = queryParameters.set('destinationPinID', <any>destinationPinID);
        }
        if (linkLevel !== undefined && linkLevel !== null) {
            queryParameters = queryParameters.set('linkLevel', <any>linkLevel);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<PlanetaryLink>>(`${this.basePath}/ws/v1/char/planetary_link`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get planetary pins
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param planetID Planet ID selector
     * @param pinID Pin ID selector
     * @param typeID Pin type ID selector
     * @param schematicID Pin schematic ID selector
     * @param lastCycleStart Pin last cycle start selector
     * @param cycleTime Pin cycle time selector
     * @param quantityPerCycle Pin quantity per cycle selector
     * @param installTime Pin install time selector
     * @param expiryTime Pin expiry time selector
     * @param productTypeID Pin product type ID selector
     * @param longitude Pin longitude selector
     * @param latitude Pin latitude selector
     * @param headRadius Pin head radius selector
     * @param headID Pin head ID selector
     * @param headLongitude Pin head longitude selector
     * @param headLatitude Pin head latitude selector
     * @param contentTypeID Pin content type ID selector
     * @param contentAmount Pin content amount selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPlanetaryPins(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, planetID?: string, pinID?: string, typeID?: string, schematicID?: string, lastCycleStart?: string, cycleTime?: string, quantityPerCycle?: string, installTime?: string, expiryTime?: string, productTypeID?: string, longitude?: string, latitude?: string, headRadius?: string, headID?: string, headLongitude?: string, headLatitude?: string, contentTypeID?: string, contentAmount?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<PlanetaryPin>>;
    public getPlanetaryPins(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, planetID?: string, pinID?: string, typeID?: string, schematicID?: string, lastCycleStart?: string, cycleTime?: string, quantityPerCycle?: string, installTime?: string, expiryTime?: string, productTypeID?: string, longitude?: string, latitude?: string, headRadius?: string, headID?: string, headLongitude?: string, headLatitude?: string, contentTypeID?: string, contentAmount?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PlanetaryPin>>>;
    public getPlanetaryPins(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, planetID?: string, pinID?: string, typeID?: string, schematicID?: string, lastCycleStart?: string, cycleTime?: string, quantityPerCycle?: string, installTime?: string, expiryTime?: string, productTypeID?: string, longitude?: string, latitude?: string, headRadius?: string, headID?: string, headLongitude?: string, headLatitude?: string, contentTypeID?: string, contentAmount?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PlanetaryPin>>>;
    public getPlanetaryPins(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, planetID?: string, pinID?: string, typeID?: string, schematicID?: string, lastCycleStart?: string, cycleTime?: string, quantityPerCycle?: string, installTime?: string, expiryTime?: string, productTypeID?: string, longitude?: string, latitude?: string, headRadius?: string, headID?: string, headLongitude?: string, headLatitude?: string, contentTypeID?: string, contentAmount?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getPlanetaryPins.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getPlanetaryPins.');
        }























        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (planetID !== undefined && planetID !== null) {
            queryParameters = queryParameters.set('planetID', <any>planetID);
        }
        if (pinID !== undefined && pinID !== null) {
            queryParameters = queryParameters.set('pinID', <any>pinID);
        }
        if (typeID !== undefined && typeID !== null) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (schematicID !== undefined && schematicID !== null) {
            queryParameters = queryParameters.set('schematicID', <any>schematicID);
        }
        if (lastCycleStart !== undefined && lastCycleStart !== null) {
            queryParameters = queryParameters.set('lastCycleStart', <any>lastCycleStart);
        }
        if (cycleTime !== undefined && cycleTime !== null) {
            queryParameters = queryParameters.set('cycleTime', <any>cycleTime);
        }
        if (quantityPerCycle !== undefined && quantityPerCycle !== null) {
            queryParameters = queryParameters.set('quantityPerCycle', <any>quantityPerCycle);
        }
        if (installTime !== undefined && installTime !== null) {
            queryParameters = queryParameters.set('installTime', <any>installTime);
        }
        if (expiryTime !== undefined && expiryTime !== null) {
            queryParameters = queryParameters.set('expiryTime', <any>expiryTime);
        }
        if (productTypeID !== undefined && productTypeID !== null) {
            queryParameters = queryParameters.set('productTypeID', <any>productTypeID);
        }
        if (longitude !== undefined && longitude !== null) {
            queryParameters = queryParameters.set('longitude', <any>longitude);
        }
        if (latitude !== undefined && latitude !== null) {
            queryParameters = queryParameters.set('latitude', <any>latitude);
        }
        if (headRadius !== undefined && headRadius !== null) {
            queryParameters = queryParameters.set('headRadius', <any>headRadius);
        }
        if (headID !== undefined && headID !== null) {
            queryParameters = queryParameters.set('headID', <any>headID);
        }
        if (headLongitude !== undefined && headLongitude !== null) {
            queryParameters = queryParameters.set('headLongitude', <any>headLongitude);
        }
        if (headLatitude !== undefined && headLatitude !== null) {
            queryParameters = queryParameters.set('headLatitude', <any>headLatitude);
        }
        if (contentTypeID !== undefined && contentTypeID !== null) {
            queryParameters = queryParameters.set('contentTypeID', <any>contentTypeID);
        }
        if (contentAmount !== undefined && contentAmount !== null) {
            queryParameters = queryParameters.set('contentAmount', <any>contentAmount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<PlanetaryPin>>(`${this.basePath}/ws/v1/char/planetary_pin`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get planetary routes
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param planetID Planet ID selector
     * @param routeID Route ID selector
     * @param sourcePinID Route source pin ID selector
     * @param destinationPinID Route destination pin ID selector
     * @param contentTypeID Route content type ID selector
     * @param quantity Route quantity selector
     * @param waypoint Route waypoint selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPlanetaryRoutes(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, planetID?: string, routeID?: string, sourcePinID?: string, destinationPinID?: string, contentTypeID?: string, quantity?: string, waypoint?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<PlanetaryRoute>>;
    public getPlanetaryRoutes(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, planetID?: string, routeID?: string, sourcePinID?: string, destinationPinID?: string, contentTypeID?: string, quantity?: string, waypoint?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PlanetaryRoute>>>;
    public getPlanetaryRoutes(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, planetID?: string, routeID?: string, sourcePinID?: string, destinationPinID?: string, contentTypeID?: string, quantity?: string, waypoint?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PlanetaryRoute>>>;
    public getPlanetaryRoutes(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, planetID?: string, routeID?: string, sourcePinID?: string, destinationPinID?: string, contentTypeID?: string, quantity?: string, waypoint?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getPlanetaryRoutes.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getPlanetaryRoutes.');
        }












        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (planetID !== undefined && planetID !== null) {
            queryParameters = queryParameters.set('planetID', <any>planetID);
        }
        if (routeID !== undefined && routeID !== null) {
            queryParameters = queryParameters.set('routeID', <any>routeID);
        }
        if (sourcePinID !== undefined && sourcePinID !== null) {
            queryParameters = queryParameters.set('sourcePinID', <any>sourcePinID);
        }
        if (destinationPinID !== undefined && destinationPinID !== null) {
            queryParameters = queryParameters.set('destinationPinID', <any>destinationPinID);
        }
        if (contentTypeID !== undefined && contentTypeID !== null) {
            queryParameters = queryParameters.set('contentTypeID', <any>contentTypeID);
        }
        if (quantity !== undefined && quantity !== null) {
            queryParameters = queryParameters.set('quantity', <any>quantity);
        }
        if (waypoint !== undefined && waypoint !== null) {
            queryParameters = queryParameters.set('waypoint', <any>waypoint);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<PlanetaryRoute>>(`${this.basePath}/ws/v1/char/planetary_route`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character research agents
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param agentID Research agent ID selector
     * @param pointsPerDay Agent points per day selector
     * @param remainderPoints Agent remainder points selector
     * @param researchStartDate Agent research start date selector
     * @param skillTypeID Agent skill type ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getResearchAgents(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, agentID?: string, pointsPerDay?: string, remainderPoints?: string, researchStartDate?: string, skillTypeID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ResearchAgent>>;
    public getResearchAgents(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, agentID?: string, pointsPerDay?: string, remainderPoints?: string, researchStartDate?: string, skillTypeID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ResearchAgent>>>;
    public getResearchAgents(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, agentID?: string, pointsPerDay?: string, remainderPoints?: string, researchStartDate?: string, skillTypeID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ResearchAgent>>>;
    public getResearchAgents(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, agentID?: string, pointsPerDay?: string, remainderPoints?: string, researchStartDate?: string, skillTypeID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getResearchAgents.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getResearchAgents.');
        }










        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (agentID !== undefined && agentID !== null) {
            queryParameters = queryParameters.set('agentID', <any>agentID);
        }
        if (pointsPerDay !== undefined && pointsPerDay !== null) {
            queryParameters = queryParameters.set('pointsPerDay', <any>pointsPerDay);
        }
        if (remainderPoints !== undefined && remainderPoints !== null) {
            queryParameters = queryParameters.set('remainderPoints', <any>remainderPoints);
        }
        if (researchStartDate !== undefined && researchStartDate !== null) {
            queryParameters = queryParameters.set('researchStartDate', <any>researchStartDate);
        }
        if (skillTypeID !== undefined && skillTypeID !== null) {
            queryParameters = queryParameters.set('skillTypeID', <any>skillTypeID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ResearchAgent>>(`${this.basePath}/ws/v1/char/research_agent`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character roles
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param roleCategory Role category selector
     * @param roleName Role name selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRoles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, roleCategory?: string, roleName?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CharacterRole>>;
    public getRoles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, roleCategory?: string, roleName?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CharacterRole>>>;
    public getRoles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, roleCategory?: string, roleName?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CharacterRole>>>;
    public getRoles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, roleCategory?: string, roleName?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getRoles.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getRoles.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (roleCategory !== undefined && roleCategory !== null) {
            queryParameters = queryParameters.set('roleCategory', <any>roleCategory);
        }
        if (roleName !== undefined && roleName !== null) {
            queryParameters = queryParameters.set('roleName', <any>roleName);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CharacterRole>>(`${this.basePath}/ws/v1/char/role`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character ship type
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param shipTypeID Ship type ID selector
     * @param shipItemID Ship item ID selector
     * @param shipName Ship name selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getShipType(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, shipTypeID?: string, shipItemID?: string, shipName?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CharacterShip>>;
    public getShipType(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, shipTypeID?: string, shipItemID?: string, shipName?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CharacterShip>>>;
    public getShipType(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, shipTypeID?: string, shipItemID?: string, shipName?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CharacterShip>>>;
    public getShipType(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, shipTypeID?: string, shipItemID?: string, shipName?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getShipType.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getShipType.');
        }








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (shipTypeID !== undefined && shipTypeID !== null) {
            queryParameters = queryParameters.set('shipTypeID', <any>shipTypeID);
        }
        if (shipItemID !== undefined && shipItemID !== null) {
            queryParameters = queryParameters.set('shipItemID', <any>shipItemID);
        }
        if (shipName !== undefined && shipName !== null) {
            queryParameters = queryParameters.set('shipName', <any>shipName);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CharacterShip>>(`${this.basePath}/ws/v1/char/ship_type`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character skill points
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param totalSkillPoints Total skill points selector
     * @param unallocatedSkillPoints Unallocated skill points selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSkillPoints(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, totalSkillPoints?: string, unallocatedSkillPoints?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CharacterSheetSkillPoints>>;
    public getSkillPoints(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, totalSkillPoints?: string, unallocatedSkillPoints?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CharacterSheetSkillPoints>>>;
    public getSkillPoints(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, totalSkillPoints?: string, unallocatedSkillPoints?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CharacterSheetSkillPoints>>>;
    public getSkillPoints(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, totalSkillPoints?: string, unallocatedSkillPoints?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getSkillPoints.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getSkillPoints.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (totalSkillPoints !== undefined && totalSkillPoints !== null) {
            queryParameters = queryParameters.set('totalSkillPoints', <any>totalSkillPoints);
        }
        if (unallocatedSkillPoints !== undefined && unallocatedSkillPoints !== null) {
            queryParameters = queryParameters.set('unallocatedSkillPoints', <any>unallocatedSkillPoints);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CharacterSheetSkillPoints>>(`${this.basePath}/ws/v1/char/skill_points`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character skills
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param typeID Skill type ID selector
     * @param trainedSkillLevel Trained skill level selector
     * @param skillpoints Skill points selector
     * @param activeSkillLevel Active skill level selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSkills(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, typeID?: string, trainedSkillLevel?: string, skillpoints?: string, activeSkillLevel?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CharacterSkill>>;
    public getSkills(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, typeID?: string, trainedSkillLevel?: string, skillpoints?: string, activeSkillLevel?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CharacterSkill>>>;
    public getSkills(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, typeID?: string, trainedSkillLevel?: string, skillpoints?: string, activeSkillLevel?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CharacterSkill>>>;
    public getSkills(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, typeID?: string, trainedSkillLevel?: string, skillpoints?: string, activeSkillLevel?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getSkills.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getSkills.');
        }









        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (typeID !== undefined && typeID !== null) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (trainedSkillLevel !== undefined && trainedSkillLevel !== null) {
            queryParameters = queryParameters.set('trainedSkillLevel', <any>trainedSkillLevel);
        }
        if (skillpoints !== undefined && skillpoints !== null) {
            queryParameters = queryParameters.set('skillpoints', <any>skillpoints);
        }
        if (activeSkillLevel !== undefined && activeSkillLevel !== null) {
            queryParameters = queryParameters.set('activeSkillLevel', <any>activeSkillLevel);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CharacterSkill>>(`${this.basePath}/ws/v1/char/skill`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character skill queue
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param endSP Skill ending skill points selector
     * @param endTime Skill training end time selector
     * @param level Skill training to level selector
     * @param queuePosition Queue position selector
     * @param startSP Starting skill points selector
     * @param startTime Training start time selector
     * @param typeID Skill type ID selector
     * @param trainingStartSP Training start skill point selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSkillsInQueue(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, endSP?: string, endTime?: string, level?: string, queuePosition?: string, startSP?: string, startTime?: string, typeID?: string, trainingStartSP?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<SkillInQueue>>;
    public getSkillsInQueue(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, endSP?: string, endTime?: string, level?: string, queuePosition?: string, startSP?: string, startTime?: string, typeID?: string, trainingStartSP?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<SkillInQueue>>>;
    public getSkillsInQueue(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, endSP?: string, endTime?: string, level?: string, queuePosition?: string, startSP?: string, startTime?: string, typeID?: string, trainingStartSP?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SkillInQueue>>>;
    public getSkillsInQueue(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, endSP?: string, endTime?: string, level?: string, queuePosition?: string, startSP?: string, startTime?: string, typeID?: string, trainingStartSP?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getSkillsInQueue.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getSkillsInQueue.');
        }













        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (endSP !== undefined && endSP !== null) {
            queryParameters = queryParameters.set('endSP', <any>endSP);
        }
        if (endTime !== undefined && endTime !== null) {
            queryParameters = queryParameters.set('endTime', <any>endTime);
        }
        if (level !== undefined && level !== null) {
            queryParameters = queryParameters.set('level', <any>level);
        }
        if (queuePosition !== undefined && queuePosition !== null) {
            queryParameters = queryParameters.set('queuePosition', <any>queuePosition);
        }
        if (startSP !== undefined && startSP !== null) {
            queryParameters = queryParameters.set('startSP', <any>startSP);
        }
        if (startTime !== undefined && startTime !== null) {
            queryParameters = queryParameters.set('startTime', <any>startTime);
        }
        if (typeID !== undefined && typeID !== null) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (trainingStartSP !== undefined && trainingStartSP !== null) {
            queryParameters = queryParameters.set('trainingStartSP', <any>trainingStartSP);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<SkillInQueue>>(`${this.basePath}/ws/v1/char/skill_queue`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character titles
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param titleID Character title ID selector
     * @param titleName Character title name selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTitles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, titleID?: string, titleName?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CharacterTitle>>;
    public getTitles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, titleID?: string, titleName?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CharacterTitle>>>;
    public getTitles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, titleID?: string, titleName?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CharacterTitle>>>;
    public getTitles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, titleID?: string, titleName?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getTitles.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getTitles.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (titleID !== undefined && titleID !== null) {
            queryParameters = queryParameters.set('titleID', <any>titleID);
        }
        if (titleName !== undefined && titleName !== null) {
            queryParameters = queryParameters.set('titleName', <any>titleName);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CharacterTitle>>(`${this.basePath}/ws/v1/char/title`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get upcoming calendar events
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param duration Event duration selector
     * @param eventDate Event date selector (milliseconds UTC)
     * @param eventID Event ID selector
     * @param eventText Event text selector
     * @param eventTitle Event title selector
     * @param ownerID Owner ID selector
     * @param ownerName Owner name selector
     * @param response Response text selector
     * @param importance Importance selector
     * @param ownerType Event owner type selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUpcomingCalendarEvents(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, duration?: string, eventDate?: string, eventID?: string, eventText?: string, eventTitle?: string, ownerID?: string, ownerName?: string, response?: string, importance?: string, ownerType?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<UpcomingCalendarEvent>>;
    public getUpcomingCalendarEvents(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, duration?: string, eventDate?: string, eventID?: string, eventText?: string, eventTitle?: string, ownerID?: string, ownerName?: string, response?: string, importance?: string, ownerType?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<UpcomingCalendarEvent>>>;
    public getUpcomingCalendarEvents(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, duration?: string, eventDate?: string, eventID?: string, eventText?: string, eventTitle?: string, ownerID?: string, ownerName?: string, response?: string, importance?: string, ownerType?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<UpcomingCalendarEvent>>>;
    public getUpcomingCalendarEvents(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, duration?: string, eventDate?: string, eventID?: string, eventText?: string, eventTitle?: string, ownerID?: string, ownerName?: string, response?: string, importance?: string, ownerType?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getUpcomingCalendarEvents.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getUpcomingCalendarEvents.');
        }















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (duration !== undefined && duration !== null) {
            queryParameters = queryParameters.set('duration', <any>duration);
        }
        if (eventDate !== undefined && eventDate !== null) {
            queryParameters = queryParameters.set('eventDate', <any>eventDate);
        }
        if (eventID !== undefined && eventID !== null) {
            queryParameters = queryParameters.set('eventID', <any>eventID);
        }
        if (eventText !== undefined && eventText !== null) {
            queryParameters = queryParameters.set('eventText', <any>eventText);
        }
        if (eventTitle !== undefined && eventTitle !== null) {
            queryParameters = queryParameters.set('eventTitle', <any>eventTitle);
        }
        if (ownerID !== undefined && ownerID !== null) {
            queryParameters = queryParameters.set('ownerID', <any>ownerID);
        }
        if (ownerName !== undefined && ownerName !== null) {
            queryParameters = queryParameters.set('ownerName', <any>ownerName);
        }
        if (response !== undefined && response !== null) {
            queryParameters = queryParameters.set('response', <any>response);
        }
        if (importance !== undefined && importance !== null) {
            queryParameters = queryParameters.set('importance', <any>importance);
        }
        if (ownerType !== undefined && ownerType !== null) {
            queryParameters = queryParameters.set('ownerType', <any>ownerType);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<UpcomingCalendarEvent>>(`${this.basePath}/ws/v1/char/calendar_events`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
