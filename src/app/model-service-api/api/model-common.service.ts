/**
 * EveKit Model API Server
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { AccountBalance } from '../model/accountBalance';
import { Asset } from '../model/asset';
import { Blueprint } from '../model/blueprint';
import { Bookmark } from '../model/bookmark';
import { Contact } from '../model/contact';
import { ContactLabel } from '../model/contactLabel';
import { Contract } from '../model/contract';
import { ContractBid } from '../model/contractBid';
import { ContractItem } from '../model/contractItem';
import { FacWarStats } from '../model/facWarStats';
import { IndustryJob } from '../model/industryJob';
import { Kill } from '../model/kill';
import { KillAttacker } from '../model/killAttacker';
import { KillItem } from '../model/killItem';
import { KillVictim } from '../model/killVictim';
import { Location } from '../model/location';
import { MarketOrder } from '../model/marketOrder';
import { ServiceError } from '../model/serviceError';
import { Standing } from '../model/standing';
import { WalletJournal } from '../model/walletJournal';
import { WalletTransaction } from '../model/walletTransaction';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ModelCommonService {

    protected basePath = 'https://evekit-model.orbital.enterprises//api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Get account balance(s)
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param division Division selector
     * @param balance Balance selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAccountBalance(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, division?: string, balance?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<AccountBalance>>;
    public getAccountBalance(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, division?: string, balance?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<AccountBalance>>>;
    public getAccountBalance(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, division?: string, balance?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<AccountBalance>>>;
    public getAccountBalance(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, division?: string, balance?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getAccountBalance.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getAccountBalance.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (division !== undefined && division !== null) {
            queryParameters = queryParameters.set('division', <any>division);
        }
        if (balance !== undefined && balance !== null) {
            queryParameters = queryParameters.set('balance', <any>balance);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<AccountBalance>>(`${this.basePath}/ws/v1/common/account_balance`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get assets
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param itemID Asset item ID selector
     * @param locationID Asset location ID selector
     * @param locationType Asset location type selector
     * @param locationFlag Asset location flag selector
     * @param typeID Asset type ID selector
     * @param quantity Asset quantity selector
     * @param singleton Asset is singleton selector
     * @param blueprintType Asset blueprint type selector
     * @param blueprintCopy Asset blueprint copy selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAssets(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, itemID?: string, locationID?: string, locationType?: string, locationFlag?: string, typeID?: string, quantity?: string, singleton?: string, blueprintType?: string, blueprintCopy?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Asset>>;
    public getAssets(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, itemID?: string, locationID?: string, locationType?: string, locationFlag?: string, typeID?: string, quantity?: string, singleton?: string, blueprintType?: string, blueprintCopy?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Asset>>>;
    public getAssets(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, itemID?: string, locationID?: string, locationType?: string, locationFlag?: string, typeID?: string, quantity?: string, singleton?: string, blueprintType?: string, blueprintCopy?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Asset>>>;
    public getAssets(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, itemID?: string, locationID?: string, locationType?: string, locationFlag?: string, typeID?: string, quantity?: string, singleton?: string, blueprintType?: string, blueprintCopy?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getAssets.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getAssets.');
        }














        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (itemID !== undefined && itemID !== null) {
            queryParameters = queryParameters.set('itemID', <any>itemID);
        }
        if (locationID !== undefined && locationID !== null) {
            queryParameters = queryParameters.set('locationID', <any>locationID);
        }
        if (locationType !== undefined && locationType !== null) {
            queryParameters = queryParameters.set('locationType', <any>locationType);
        }
        if (locationFlag !== undefined && locationFlag !== null) {
            queryParameters = queryParameters.set('locationFlag', <any>locationFlag);
        }
        if (typeID !== undefined && typeID !== null) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (quantity !== undefined && quantity !== null) {
            queryParameters = queryParameters.set('quantity', <any>quantity);
        }
        if (singleton !== undefined && singleton !== null) {
            queryParameters = queryParameters.set('singleton', <any>singleton);
        }
        if (blueprintType !== undefined && blueprintType !== null) {
            queryParameters = queryParameters.set('blueprintType', <any>blueprintType);
        }
        if (blueprintCopy !== undefined && blueprintCopy !== null) {
            queryParameters = queryParameters.set('blueprintCopy', <any>blueprintCopy);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Asset>>(`${this.basePath}/ws/v1/common/asset`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get blueprints
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param itemID Blueprint item ID selector
     * @param locationID Blueprint location ID selector
     * @param locationFlag Blueprint location flag selector
     * @param typeID Blueprint type ID selector
     * @param quantity Blueprint quantity selector
     * @param timeEfficiency Blueprint time efficiency selector
     * @param materialEfficiency Blueprint material efficiency selector
     * @param runs Blueprint runs selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getBlueprints(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, itemID?: string, locationID?: string, locationFlag?: string, typeID?: string, quantity?: string, timeEfficiency?: string, materialEfficiency?: string, runs?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Blueprint>>;
    public getBlueprints(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, itemID?: string, locationID?: string, locationFlag?: string, typeID?: string, quantity?: string, timeEfficiency?: string, materialEfficiency?: string, runs?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Blueprint>>>;
    public getBlueprints(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, itemID?: string, locationID?: string, locationFlag?: string, typeID?: string, quantity?: string, timeEfficiency?: string, materialEfficiency?: string, runs?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Blueprint>>>;
    public getBlueprints(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, itemID?: string, locationID?: string, locationFlag?: string, typeID?: string, quantity?: string, timeEfficiency?: string, materialEfficiency?: string, runs?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getBlueprints.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getBlueprints.');
        }













        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (itemID !== undefined && itemID !== null) {
            queryParameters = queryParameters.set('itemID', <any>itemID);
        }
        if (locationID !== undefined && locationID !== null) {
            queryParameters = queryParameters.set('locationID', <any>locationID);
        }
        if (locationFlag !== undefined && locationFlag !== null) {
            queryParameters = queryParameters.set('locationFlag', <any>locationFlag);
        }
        if (typeID !== undefined && typeID !== null) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (quantity !== undefined && quantity !== null) {
            queryParameters = queryParameters.set('quantity', <any>quantity);
        }
        if (timeEfficiency !== undefined && timeEfficiency !== null) {
            queryParameters = queryParameters.set('timeEfficiency', <any>timeEfficiency);
        }
        if (materialEfficiency !== undefined && materialEfficiency !== null) {
            queryParameters = queryParameters.set('materialEfficiency', <any>materialEfficiency);
        }
        if (runs !== undefined && runs !== null) {
            queryParameters = queryParameters.set('runs', <any>runs);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Blueprint>>(`${this.basePath}/ws/v1/common/blueprint`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get bookmarks
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param folderID Bookmark folder ID selector
     * @param folderName Bookmark folder name selector
     * @param folderCreatorID Bookmark folder creator ID selector
     * @param bookmarkID Bookmark ID selector
     * @param bookmarkCreatorID Bookmark creator ID selector
     * @param created Bookmark created selector
     * @param itemID Bookmark item ID selector
     * @param typeID Bookmark type ID selector
     * @param locationID Bookmark location ID selector
     * @param x Bookmark x coordinate selector
     * @param y Bookmark y coordinate selector
     * @param z Bookmark z coordinate selector
     * @param memo Bookmark memo selector
     * @param note Bookmark note selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getBookmarks(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, folderID?: string, folderName?: string, folderCreatorID?: string, bookmarkID?: string, bookmarkCreatorID?: string, created?: string, itemID?: string, typeID?: string, locationID?: string, x?: string, y?: string, z?: string, memo?: string, note?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Bookmark>>;
    public getBookmarks(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, folderID?: string, folderName?: string, folderCreatorID?: string, bookmarkID?: string, bookmarkCreatorID?: string, created?: string, itemID?: string, typeID?: string, locationID?: string, x?: string, y?: string, z?: string, memo?: string, note?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Bookmark>>>;
    public getBookmarks(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, folderID?: string, folderName?: string, folderCreatorID?: string, bookmarkID?: string, bookmarkCreatorID?: string, created?: string, itemID?: string, typeID?: string, locationID?: string, x?: string, y?: string, z?: string, memo?: string, note?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Bookmark>>>;
    public getBookmarks(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, folderID?: string, folderName?: string, folderCreatorID?: string, bookmarkID?: string, bookmarkCreatorID?: string, created?: string, itemID?: string, typeID?: string, locationID?: string, x?: string, y?: string, z?: string, memo?: string, note?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getBookmarks.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getBookmarks.');
        }



















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (folderID !== undefined && folderID !== null) {
            queryParameters = queryParameters.set('folderID', <any>folderID);
        }
        if (folderName !== undefined && folderName !== null) {
            queryParameters = queryParameters.set('folderName', <any>folderName);
        }
        if (folderCreatorID !== undefined && folderCreatorID !== null) {
            queryParameters = queryParameters.set('folderCreatorID', <any>folderCreatorID);
        }
        if (bookmarkID !== undefined && bookmarkID !== null) {
            queryParameters = queryParameters.set('bookmarkID', <any>bookmarkID);
        }
        if (bookmarkCreatorID !== undefined && bookmarkCreatorID !== null) {
            queryParameters = queryParameters.set('bookmarkCreatorID', <any>bookmarkCreatorID);
        }
        if (created !== undefined && created !== null) {
            queryParameters = queryParameters.set('created', <any>created);
        }
        if (itemID !== undefined && itemID !== null) {
            queryParameters = queryParameters.set('itemID', <any>itemID);
        }
        if (typeID !== undefined && typeID !== null) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (locationID !== undefined && locationID !== null) {
            queryParameters = queryParameters.set('locationID', <any>locationID);
        }
        if (x !== undefined && x !== null) {
            queryParameters = queryParameters.set('x', <any>x);
        }
        if (y !== undefined && y !== null) {
            queryParameters = queryParameters.set('y', <any>y);
        }
        if (z !== undefined && z !== null) {
            queryParameters = queryParameters.set('z', <any>z);
        }
        if (memo !== undefined && memo !== null) {
            queryParameters = queryParameters.set('memo', <any>memo);
        }
        if (note !== undefined && note !== null) {
            queryParameters = queryParameters.set('note', <any>note);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Bookmark>>(`${this.basePath}/ws/v1/common/bookmark`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get contact labels
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param list Contact list selector
     * @param labelID Contact label ID selector
     * @param name Contact label name selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getContactLabels(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, list?: string, labelID?: string, name?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ContactLabel>>;
    public getContactLabels(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, list?: string, labelID?: string, name?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ContactLabel>>>;
    public getContactLabels(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, list?: string, labelID?: string, name?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ContactLabel>>>;
    public getContactLabels(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, list?: string, labelID?: string, name?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getContactLabels.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getContactLabels.');
        }








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (list !== undefined && list !== null) {
            queryParameters = queryParameters.set('list', <any>list);
        }
        if (labelID !== undefined && labelID !== null) {
            queryParameters = queryParameters.set('labelID', <any>labelID);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ContactLabel>>(`${this.basePath}/ws/v1/common/contact_label`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get contacts
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param list Contact list selector
     * @param contactID Contact ID selector
     * @param standing Contact standing selector
     * @param contactType Contact type selector
     * @param inWatchlist Contact in watch list selector
     * @param isBlocked Contact is blocked selector
     * @param labelID Contact label selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getContacts(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, list?: string, contactID?: string, standing?: string, contactType?: string, inWatchlist?: string, isBlocked?: string, labelID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Contact>>;
    public getContacts(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, list?: string, contactID?: string, standing?: string, contactType?: string, inWatchlist?: string, isBlocked?: string, labelID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Contact>>>;
    public getContacts(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, list?: string, contactID?: string, standing?: string, contactType?: string, inWatchlist?: string, isBlocked?: string, labelID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Contact>>>;
    public getContacts(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, list?: string, contactID?: string, standing?: string, contactType?: string, inWatchlist?: string, isBlocked?: string, labelID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getContacts.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getContacts.');
        }












        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (list !== undefined && list !== null) {
            queryParameters = queryParameters.set('list', <any>list);
        }
        if (contactID !== undefined && contactID !== null) {
            queryParameters = queryParameters.set('contactID', <any>contactID);
        }
        if (standing !== undefined && standing !== null) {
            queryParameters = queryParameters.set('standing', <any>standing);
        }
        if (contactType !== undefined && contactType !== null) {
            queryParameters = queryParameters.set('contactType', <any>contactType);
        }
        if (inWatchlist !== undefined && inWatchlist !== null) {
            queryParameters = queryParameters.set('inWatchlist', <any>inWatchlist);
        }
        if (isBlocked !== undefined && isBlocked !== null) {
            queryParameters = queryParameters.set('isBlocked', <any>isBlocked);
        }
        if (labelID !== undefined && labelID !== null) {
            queryParameters = queryParameters.set('labelID', <any>labelID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Contact>>(`${this.basePath}/ws/v1/common/contact`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get contract bids
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param bidID Contract bid ID selector
     * @param contractID Contract ID selector
     * @param bidderID Contract bid bidder ID selector
     * @param dateBid Contract bid date selector
     * @param amount Contract bid amount selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getContractBids(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, bidID?: string, contractID?: string, bidderID?: string, dateBid?: string, amount?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ContractBid>>;
    public getContractBids(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, bidID?: string, contractID?: string, bidderID?: string, dateBid?: string, amount?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ContractBid>>>;
    public getContractBids(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, bidID?: string, contractID?: string, bidderID?: string, dateBid?: string, amount?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ContractBid>>>;
    public getContractBids(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, bidID?: string, contractID?: string, bidderID?: string, dateBid?: string, amount?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getContractBids.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getContractBids.');
        }










        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (bidID !== undefined && bidID !== null) {
            queryParameters = queryParameters.set('bidID', <any>bidID);
        }
        if (contractID !== undefined && contractID !== null) {
            queryParameters = queryParameters.set('contractID', <any>contractID);
        }
        if (bidderID !== undefined && bidderID !== null) {
            queryParameters = queryParameters.set('bidderID', <any>bidderID);
        }
        if (dateBid !== undefined && dateBid !== null) {
            queryParameters = queryParameters.set('dateBid', <any>dateBid);
        }
        if (amount !== undefined && amount !== null) {
            queryParameters = queryParameters.set('amount', <any>amount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ContractBid>>(`${this.basePath}/ws/v1/common/contract_bid`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get contract items
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param contractID Contract ID selector
     * @param recordID Contract item record ID selector
     * @param typeID Contract item type ID selector
     * @param quantity Contract item quantity selector
     * @param rawQuantity Contract item raw quantity selector
     * @param singleton Contract item singleton selector
     * @param included Contract item included selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getContractItems(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, contractID?: string, recordID?: string, typeID?: string, quantity?: string, rawQuantity?: string, singleton?: string, included?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ContractItem>>;
    public getContractItems(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, contractID?: string, recordID?: string, typeID?: string, quantity?: string, rawQuantity?: string, singleton?: string, included?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ContractItem>>>;
    public getContractItems(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, contractID?: string, recordID?: string, typeID?: string, quantity?: string, rawQuantity?: string, singleton?: string, included?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ContractItem>>>;
    public getContractItems(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, contractID?: string, recordID?: string, typeID?: string, quantity?: string, rawQuantity?: string, singleton?: string, included?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getContractItems.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getContractItems.');
        }












        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (contractID !== undefined && contractID !== null) {
            queryParameters = queryParameters.set('contractID', <any>contractID);
        }
        if (recordID !== undefined && recordID !== null) {
            queryParameters = queryParameters.set('recordID', <any>recordID);
        }
        if (typeID !== undefined && typeID !== null) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (quantity !== undefined && quantity !== null) {
            queryParameters = queryParameters.set('quantity', <any>quantity);
        }
        if (rawQuantity !== undefined && rawQuantity !== null) {
            queryParameters = queryParameters.set('rawQuantity', <any>rawQuantity);
        }
        if (singleton !== undefined && singleton !== null) {
            queryParameters = queryParameters.set('singleton', <any>singleton);
        }
        if (included !== undefined && included !== null) {
            queryParameters = queryParameters.set('included', <any>included);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ContractItem>>(`${this.basePath}/ws/v1/common/contract_item`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get contracts
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param contractID Contract ID selector
     * @param issuerID Contract issuer ID selector
     * @param issuerCorpID Contract issuer corporation ID selector
     * @param assigneeID Contract assignee ID selector
     * @param acceptorID Contract acceptor ID selector
     * @param startStationID Contract start station ID selector
     * @param endStationID Contract end station ID selector
     * @param type Contract type selector
     * @param status Contract status selector
     * @param title Contract title selector
     * @param forCorp Contract for corporation selector
     * @param availability Contract availability selector
     * @param dateIssued Contract date issued selector
     * @param dateExpired Contract date expired selector
     * @param dateAccepted Contract date accepted selector
     * @param numDays Contract duration (days) selector
     * @param dateCompleted Contract date completed selector
     * @param price Contract price selector
     * @param reward Contract reward value selector
     * @param collateral Contract collateral value selector
     * @param buyout Contract buyout price selector
     * @param volume Contract volume selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getContracts(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, contractID?: string, issuerID?: string, issuerCorpID?: string, assigneeID?: string, acceptorID?: string, startStationID?: string, endStationID?: string, type?: string, status?: string, title?: string, forCorp?: string, availability?: string, dateIssued?: string, dateExpired?: string, dateAccepted?: string, numDays?: string, dateCompleted?: string, price?: string, reward?: string, collateral?: string, buyout?: string, volume?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Contract>>;
    public getContracts(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, contractID?: string, issuerID?: string, issuerCorpID?: string, assigneeID?: string, acceptorID?: string, startStationID?: string, endStationID?: string, type?: string, status?: string, title?: string, forCorp?: string, availability?: string, dateIssued?: string, dateExpired?: string, dateAccepted?: string, numDays?: string, dateCompleted?: string, price?: string, reward?: string, collateral?: string, buyout?: string, volume?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Contract>>>;
    public getContracts(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, contractID?: string, issuerID?: string, issuerCorpID?: string, assigneeID?: string, acceptorID?: string, startStationID?: string, endStationID?: string, type?: string, status?: string, title?: string, forCorp?: string, availability?: string, dateIssued?: string, dateExpired?: string, dateAccepted?: string, numDays?: string, dateCompleted?: string, price?: string, reward?: string, collateral?: string, buyout?: string, volume?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Contract>>>;
    public getContracts(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, contractID?: string, issuerID?: string, issuerCorpID?: string, assigneeID?: string, acceptorID?: string, startStationID?: string, endStationID?: string, type?: string, status?: string, title?: string, forCorp?: string, availability?: string, dateIssued?: string, dateExpired?: string, dateAccepted?: string, numDays?: string, dateCompleted?: string, price?: string, reward?: string, collateral?: string, buyout?: string, volume?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getContracts.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getContracts.');
        }



























        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (contractID !== undefined && contractID !== null) {
            queryParameters = queryParameters.set('contractID', <any>contractID);
        }
        if (issuerID !== undefined && issuerID !== null) {
            queryParameters = queryParameters.set('issuerID', <any>issuerID);
        }
        if (issuerCorpID !== undefined && issuerCorpID !== null) {
            queryParameters = queryParameters.set('issuerCorpID', <any>issuerCorpID);
        }
        if (assigneeID !== undefined && assigneeID !== null) {
            queryParameters = queryParameters.set('assigneeID', <any>assigneeID);
        }
        if (acceptorID !== undefined && acceptorID !== null) {
            queryParameters = queryParameters.set('acceptorID', <any>acceptorID);
        }
        if (startStationID !== undefined && startStationID !== null) {
            queryParameters = queryParameters.set('startStationID', <any>startStationID);
        }
        if (endStationID !== undefined && endStationID !== null) {
            queryParameters = queryParameters.set('endStationID', <any>endStationID);
        }
        if (type !== undefined && type !== null) {
            queryParameters = queryParameters.set('type', <any>type);
        }
        if (status !== undefined && status !== null) {
            queryParameters = queryParameters.set('status', <any>status);
        }
        if (title !== undefined && title !== null) {
            queryParameters = queryParameters.set('title', <any>title);
        }
        if (forCorp !== undefined && forCorp !== null) {
            queryParameters = queryParameters.set('forCorp', <any>forCorp);
        }
        if (availability !== undefined && availability !== null) {
            queryParameters = queryParameters.set('availability', <any>availability);
        }
        if (dateIssued !== undefined && dateIssued !== null) {
            queryParameters = queryParameters.set('dateIssued', <any>dateIssued);
        }
        if (dateExpired !== undefined && dateExpired !== null) {
            queryParameters = queryParameters.set('dateExpired', <any>dateExpired);
        }
        if (dateAccepted !== undefined && dateAccepted !== null) {
            queryParameters = queryParameters.set('dateAccepted', <any>dateAccepted);
        }
        if (numDays !== undefined && numDays !== null) {
            queryParameters = queryParameters.set('numDays', <any>numDays);
        }
        if (dateCompleted !== undefined && dateCompleted !== null) {
            queryParameters = queryParameters.set('dateCompleted', <any>dateCompleted);
        }
        if (price !== undefined && price !== null) {
            queryParameters = queryParameters.set('price', <any>price);
        }
        if (reward !== undefined && reward !== null) {
            queryParameters = queryParameters.set('reward', <any>reward);
        }
        if (collateral !== undefined && collateral !== null) {
            queryParameters = queryParameters.set('collateral', <any>collateral);
        }
        if (buyout !== undefined && buyout !== null) {
            queryParameters = queryParameters.set('buyout', <any>buyout);
        }
        if (volume !== undefined && volume !== null) {
            queryParameters = queryParameters.set('volume', <any>volume);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Contract>>(`${this.basePath}/ws/v1/common/contract`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get faction war statistics
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param currentRank Faction war statistics current rank selector
     * @param enlisted Faction war statistics enlisted indicator selector
     * @param factionID Faction war statistics faction ID selector
     * @param highestRank Faction war statistics highest rank selector
     * @param killsLastWeek Faction war statistics kill last week selector
     * @param killsTotal Faction war statistics total kills selector
     * @param killsYesterday Faction war statistics kills yesterday selector
     * @param pilots Faction war statistics pilot count selector
     * @param victoryPointsLastWeek Faction war statistics victory points last week selector
     * @param victoryPointsTotal Faction war statistics victory points total selector
     * @param victoryPointsYesterday Faction war statistics victory points yesterday selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFacWarStats(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, currentRank?: string, enlisted?: string, factionID?: string, highestRank?: string, killsLastWeek?: string, killsTotal?: string, killsYesterday?: string, pilots?: string, victoryPointsLastWeek?: string, victoryPointsTotal?: string, victoryPointsYesterday?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<FacWarStats>>;
    public getFacWarStats(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, currentRank?: string, enlisted?: string, factionID?: string, highestRank?: string, killsLastWeek?: string, killsTotal?: string, killsYesterday?: string, pilots?: string, victoryPointsLastWeek?: string, victoryPointsTotal?: string, victoryPointsYesterday?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FacWarStats>>>;
    public getFacWarStats(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, currentRank?: string, enlisted?: string, factionID?: string, highestRank?: string, killsLastWeek?: string, killsTotal?: string, killsYesterday?: string, pilots?: string, victoryPointsLastWeek?: string, victoryPointsTotal?: string, victoryPointsYesterday?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FacWarStats>>>;
    public getFacWarStats(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, currentRank?: string, enlisted?: string, factionID?: string, highestRank?: string, killsLastWeek?: string, killsTotal?: string, killsYesterday?: string, pilots?: string, victoryPointsLastWeek?: string, victoryPointsTotal?: string, victoryPointsYesterday?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getFacWarStats.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getFacWarStats.');
        }
















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (currentRank !== undefined && currentRank !== null) {
            queryParameters = queryParameters.set('currentRank', <any>currentRank);
        }
        if (enlisted !== undefined && enlisted !== null) {
            queryParameters = queryParameters.set('enlisted', <any>enlisted);
        }
        if (factionID !== undefined && factionID !== null) {
            queryParameters = queryParameters.set('factionID', <any>factionID);
        }
        if (highestRank !== undefined && highestRank !== null) {
            queryParameters = queryParameters.set('highestRank', <any>highestRank);
        }
        if (killsLastWeek !== undefined && killsLastWeek !== null) {
            queryParameters = queryParameters.set('killsLastWeek', <any>killsLastWeek);
        }
        if (killsTotal !== undefined && killsTotal !== null) {
            queryParameters = queryParameters.set('killsTotal', <any>killsTotal);
        }
        if (killsYesterday !== undefined && killsYesterday !== null) {
            queryParameters = queryParameters.set('killsYesterday', <any>killsYesterday);
        }
        if (pilots !== undefined && pilots !== null) {
            queryParameters = queryParameters.set('pilots', <any>pilots);
        }
        if (victoryPointsLastWeek !== undefined && victoryPointsLastWeek !== null) {
            queryParameters = queryParameters.set('victoryPointsLastWeek', <any>victoryPointsLastWeek);
        }
        if (victoryPointsTotal !== undefined && victoryPointsTotal !== null) {
            queryParameters = queryParameters.set('victoryPointsTotal', <any>victoryPointsTotal);
        }
        if (victoryPointsYesterday !== undefined && victoryPointsYesterday !== null) {
            queryParameters = queryParameters.set('victoryPointsYesterday', <any>victoryPointsYesterday);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<FacWarStats>>(`${this.basePath}/ws/v1/common/fac_war_stats`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get industry jobs
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param jobID Industry job ID selector
     * @param installerID Industry job installer ID selector
     * @param facilityID Industry job facility ID selector
     * @param stationID Industry job station ID selector
     * @param activityID Industry job activity ID selector
     * @param blueprintID Industry job blueprint ID selector
     * @param blueprintTypeID Industry job blueprint type ID selector
     * @param blueprintLocationID Industry job blueprint location ID selector
     * @param outputLocationID Industry job output location ID selector
     * @param runs Industry job runs selector
     * @param cost Industry job cost selector
     * @param licensedRuns Industry job licensed runs selector
     * @param probability Industry job probability selector
     * @param productTypeID Industry job product type ID selector
     * @param status Industry job status selector
     * @param timeInSeconds Industry job time in seconds selector
     * @param startDate Industry job start date selector
     * @param endDate Industry job end date selector
     * @param pauseDate Industry job pause date selector
     * @param completedDate Industry job completed date selector
     * @param completedCharacterID Industry job completed character ID selector
     * @param successfulRuns Industry job successful runs selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getIndustryJobs(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, jobID?: string, installerID?: string, facilityID?: string, stationID?: string, activityID?: string, blueprintID?: string, blueprintTypeID?: string, blueprintLocationID?: string, outputLocationID?: string, runs?: string, cost?: string, licensedRuns?: string, probability?: string, productTypeID?: string, status?: string, timeInSeconds?: string, startDate?: string, endDate?: string, pauseDate?: string, completedDate?: string, completedCharacterID?: string, successfulRuns?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<IndustryJob>>;
    public getIndustryJobs(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, jobID?: string, installerID?: string, facilityID?: string, stationID?: string, activityID?: string, blueprintID?: string, blueprintTypeID?: string, blueprintLocationID?: string, outputLocationID?: string, runs?: string, cost?: string, licensedRuns?: string, probability?: string, productTypeID?: string, status?: string, timeInSeconds?: string, startDate?: string, endDate?: string, pauseDate?: string, completedDate?: string, completedCharacterID?: string, successfulRuns?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<IndustryJob>>>;
    public getIndustryJobs(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, jobID?: string, installerID?: string, facilityID?: string, stationID?: string, activityID?: string, blueprintID?: string, blueprintTypeID?: string, blueprintLocationID?: string, outputLocationID?: string, runs?: string, cost?: string, licensedRuns?: string, probability?: string, productTypeID?: string, status?: string, timeInSeconds?: string, startDate?: string, endDate?: string, pauseDate?: string, completedDate?: string, completedCharacterID?: string, successfulRuns?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<IndustryJob>>>;
    public getIndustryJobs(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, jobID?: string, installerID?: string, facilityID?: string, stationID?: string, activityID?: string, blueprintID?: string, blueprintTypeID?: string, blueprintLocationID?: string, outputLocationID?: string, runs?: string, cost?: string, licensedRuns?: string, probability?: string, productTypeID?: string, status?: string, timeInSeconds?: string, startDate?: string, endDate?: string, pauseDate?: string, completedDate?: string, completedCharacterID?: string, successfulRuns?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getIndustryJobs.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getIndustryJobs.');
        }



























        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (jobID !== undefined && jobID !== null) {
            queryParameters = queryParameters.set('jobID', <any>jobID);
        }
        if (installerID !== undefined && installerID !== null) {
            queryParameters = queryParameters.set('installerID', <any>installerID);
        }
        if (facilityID !== undefined && facilityID !== null) {
            queryParameters = queryParameters.set('facilityID', <any>facilityID);
        }
        if (stationID !== undefined && stationID !== null) {
            queryParameters = queryParameters.set('stationID', <any>stationID);
        }
        if (activityID !== undefined && activityID !== null) {
            queryParameters = queryParameters.set('activityID', <any>activityID);
        }
        if (blueprintID !== undefined && blueprintID !== null) {
            queryParameters = queryParameters.set('blueprintID', <any>blueprintID);
        }
        if (blueprintTypeID !== undefined && blueprintTypeID !== null) {
            queryParameters = queryParameters.set('blueprintTypeID', <any>blueprintTypeID);
        }
        if (blueprintLocationID !== undefined && blueprintLocationID !== null) {
            queryParameters = queryParameters.set('blueprintLocationID', <any>blueprintLocationID);
        }
        if (outputLocationID !== undefined && outputLocationID !== null) {
            queryParameters = queryParameters.set('outputLocationID', <any>outputLocationID);
        }
        if (runs !== undefined && runs !== null) {
            queryParameters = queryParameters.set('runs', <any>runs);
        }
        if (cost !== undefined && cost !== null) {
            queryParameters = queryParameters.set('cost', <any>cost);
        }
        if (licensedRuns !== undefined && licensedRuns !== null) {
            queryParameters = queryParameters.set('licensedRuns', <any>licensedRuns);
        }
        if (probability !== undefined && probability !== null) {
            queryParameters = queryParameters.set('probability', <any>probability);
        }
        if (productTypeID !== undefined && productTypeID !== null) {
            queryParameters = queryParameters.set('productTypeID', <any>productTypeID);
        }
        if (status !== undefined && status !== null) {
            queryParameters = queryParameters.set('status', <any>status);
        }
        if (timeInSeconds !== undefined && timeInSeconds !== null) {
            queryParameters = queryParameters.set('timeInSeconds', <any>timeInSeconds);
        }
        if (startDate !== undefined && startDate !== null) {
            queryParameters = queryParameters.set('startDate', <any>startDate);
        }
        if (endDate !== undefined && endDate !== null) {
            queryParameters = queryParameters.set('endDate', <any>endDate);
        }
        if (pauseDate !== undefined && pauseDate !== null) {
            queryParameters = queryParameters.set('pauseDate', <any>pauseDate);
        }
        if (completedDate !== undefined && completedDate !== null) {
            queryParameters = queryParameters.set('completedDate', <any>completedDate);
        }
        if (completedCharacterID !== undefined && completedCharacterID !== null) {
            queryParameters = queryParameters.set('completedCharacterID', <any>completedCharacterID);
        }
        if (successfulRuns !== undefined && successfulRuns !== null) {
            queryParameters = queryParameters.set('successfulRuns', <any>successfulRuns);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<IndustryJob>>(`${this.basePath}/ws/v1/common/industry_job`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get wallet journal entries
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param division Wallet journal division selector
     * @param refID Journal entry ref ID selector
     * @param date Journal entry date selector
     * @param refType Journal entry ref type selector
     * @param firstPartyID Journal entry first party ID selector
     * @param secondPartyID Journal entry second party ID selector
     * @param argName1 Journal entry argument name selector
     * @param argID1 Journal entry argument ID selector
     * @param amount Journal entry amount selector
     * @param balance Journal entry balance selector
     * @param reason Journal entry reason selector
     * @param taxReceiverID Journal entry tax receiver ID selector
     * @param taxAmount Journal entry tax amount selector
     * @param contextID Context ID selector
     * @param contextType Context type selector
     * @param description Description selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getJournalEntries(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, division?: string, refID?: string, date?: string, refType?: string, firstPartyID?: string, secondPartyID?: string, argName1?: string, argID1?: string, amount?: string, balance?: string, reason?: string, taxReceiverID?: string, taxAmount?: string, contextID?: string, contextType?: string, description?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<WalletJournal>>;
    public getJournalEntries(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, division?: string, refID?: string, date?: string, refType?: string, firstPartyID?: string, secondPartyID?: string, argName1?: string, argID1?: string, amount?: string, balance?: string, reason?: string, taxReceiverID?: string, taxAmount?: string, contextID?: string, contextType?: string, description?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<WalletJournal>>>;
    public getJournalEntries(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, division?: string, refID?: string, date?: string, refType?: string, firstPartyID?: string, secondPartyID?: string, argName1?: string, argID1?: string, amount?: string, balance?: string, reason?: string, taxReceiverID?: string, taxAmount?: string, contextID?: string, contextType?: string, description?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<WalletJournal>>>;
    public getJournalEntries(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, division?: string, refID?: string, date?: string, refType?: string, firstPartyID?: string, secondPartyID?: string, argName1?: string, argID1?: string, amount?: string, balance?: string, reason?: string, taxReceiverID?: string, taxAmount?: string, contextID?: string, contextType?: string, description?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getJournalEntries.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getJournalEntries.');
        }





















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (division !== undefined && division !== null) {
            queryParameters = queryParameters.set('division', <any>division);
        }
        if (refID !== undefined && refID !== null) {
            queryParameters = queryParameters.set('refID', <any>refID);
        }
        if (date !== undefined && date !== null) {
            queryParameters = queryParameters.set('date', <any>date);
        }
        if (refType !== undefined && refType !== null) {
            queryParameters = queryParameters.set('refType', <any>refType);
        }
        if (firstPartyID !== undefined && firstPartyID !== null) {
            queryParameters = queryParameters.set('firstPartyID', <any>firstPartyID);
        }
        if (secondPartyID !== undefined && secondPartyID !== null) {
            queryParameters = queryParameters.set('secondPartyID', <any>secondPartyID);
        }
        if (argName1 !== undefined && argName1 !== null) {
            queryParameters = queryParameters.set('argName1', <any>argName1);
        }
        if (argID1 !== undefined && argID1 !== null) {
            queryParameters = queryParameters.set('argID1', <any>argID1);
        }
        if (amount !== undefined && amount !== null) {
            queryParameters = queryParameters.set('amount', <any>amount);
        }
        if (balance !== undefined && balance !== null) {
            queryParameters = queryParameters.set('balance', <any>balance);
        }
        if (reason !== undefined && reason !== null) {
            queryParameters = queryParameters.set('reason', <any>reason);
        }
        if (taxReceiverID !== undefined && taxReceiverID !== null) {
            queryParameters = queryParameters.set('taxReceiverID', <any>taxReceiverID);
        }
        if (taxAmount !== undefined && taxAmount !== null) {
            queryParameters = queryParameters.set('taxAmount', <any>taxAmount);
        }
        if (contextID !== undefined && contextID !== null) {
            queryParameters = queryParameters.set('contextID', <any>contextID);
        }
        if (contextType !== undefined && contextType !== null) {
            queryParameters = queryParameters.set('contextType', <any>contextType);
        }
        if (description !== undefined && description !== null) {
            queryParameters = queryParameters.set('description', <any>description);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<WalletJournal>>(`${this.basePath}/ws/v1/common/wallet_journal`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get kill attackers
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param killID Kill ID selector
     * @param attackerCharacterID Kill attacker character ID selector
     * @param allianceID Kill attacker alliance ID selector
     * @param attackerCorporationID Kill attacker corporation ID selector
     * @param damageDone Kill attacker damage done selector
     * @param factionID Kill attacker faction ID selector
     * @param securityStatus Kill attacker security status selector
     * @param shipTypeID Kill attacker ship type ID selector
     * @param weaponTypeID Kill attacker weapon type ID selector
     * @param finalBlow Kill attacker final blow selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getKillAttackers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, killID?: string, attackerCharacterID?: string, allianceID?: string, attackerCorporationID?: string, damageDone?: string, factionID?: string, securityStatus?: string, shipTypeID?: string, weaponTypeID?: string, finalBlow?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<KillAttacker>>;
    public getKillAttackers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, killID?: string, attackerCharacterID?: string, allianceID?: string, attackerCorporationID?: string, damageDone?: string, factionID?: string, securityStatus?: string, shipTypeID?: string, weaponTypeID?: string, finalBlow?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<KillAttacker>>>;
    public getKillAttackers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, killID?: string, attackerCharacterID?: string, allianceID?: string, attackerCorporationID?: string, damageDone?: string, factionID?: string, securityStatus?: string, shipTypeID?: string, weaponTypeID?: string, finalBlow?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<KillAttacker>>>;
    public getKillAttackers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, killID?: string, attackerCharacterID?: string, allianceID?: string, attackerCorporationID?: string, damageDone?: string, factionID?: string, securityStatus?: string, shipTypeID?: string, weaponTypeID?: string, finalBlow?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getKillAttackers.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getKillAttackers.');
        }















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (killID !== undefined && killID !== null) {
            queryParameters = queryParameters.set('killID', <any>killID);
        }
        if (attackerCharacterID !== undefined && attackerCharacterID !== null) {
            queryParameters = queryParameters.set('attackerCharacterID', <any>attackerCharacterID);
        }
        if (allianceID !== undefined && allianceID !== null) {
            queryParameters = queryParameters.set('allianceID', <any>allianceID);
        }
        if (attackerCorporationID !== undefined && attackerCorporationID !== null) {
            queryParameters = queryParameters.set('attackerCorporationID', <any>attackerCorporationID);
        }
        if (damageDone !== undefined && damageDone !== null) {
            queryParameters = queryParameters.set('damageDone', <any>damageDone);
        }
        if (factionID !== undefined && factionID !== null) {
            queryParameters = queryParameters.set('factionID', <any>factionID);
        }
        if (securityStatus !== undefined && securityStatus !== null) {
            queryParameters = queryParameters.set('securityStatus', <any>securityStatus);
        }
        if (shipTypeID !== undefined && shipTypeID !== null) {
            queryParameters = queryParameters.set('shipTypeID', <any>shipTypeID);
        }
        if (weaponTypeID !== undefined && weaponTypeID !== null) {
            queryParameters = queryParameters.set('weaponTypeID', <any>weaponTypeID);
        }
        if (finalBlow !== undefined && finalBlow !== null) {
            queryParameters = queryParameters.set('finalBlow', <any>finalBlow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<KillAttacker>>(`${this.basePath}/ws/v1/common/kill_attacker`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get kill items
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param killID Kill ID selector
     * @param typeID Kill item type ID selector
     * @param flag Kill item flag selector
     * @param qtyDestroyed Kill item quantity destroyed selector
     * @param qtyDropped Kill item quantity dropped selector
     * @param singleton Kill item singleton selector
     * @param sequence Kill item sequence selector
     * @param containerSequence Kill item container sequence selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getKillItems(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, killID?: string, typeID?: string, flag?: string, qtyDestroyed?: string, qtyDropped?: string, singleton?: string, sequence?: string, containerSequence?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<KillItem>>;
    public getKillItems(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, killID?: string, typeID?: string, flag?: string, qtyDestroyed?: string, qtyDropped?: string, singleton?: string, sequence?: string, containerSequence?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<KillItem>>>;
    public getKillItems(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, killID?: string, typeID?: string, flag?: string, qtyDestroyed?: string, qtyDropped?: string, singleton?: string, sequence?: string, containerSequence?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<KillItem>>>;
    public getKillItems(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, killID?: string, typeID?: string, flag?: string, qtyDestroyed?: string, qtyDropped?: string, singleton?: string, sequence?: string, containerSequence?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getKillItems.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getKillItems.');
        }













        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (killID !== undefined && killID !== null) {
            queryParameters = queryParameters.set('killID', <any>killID);
        }
        if (typeID !== undefined && typeID !== null) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (flag !== undefined && flag !== null) {
            queryParameters = queryParameters.set('flag', <any>flag);
        }
        if (qtyDestroyed !== undefined && qtyDestroyed !== null) {
            queryParameters = queryParameters.set('qtyDestroyed', <any>qtyDestroyed);
        }
        if (qtyDropped !== undefined && qtyDropped !== null) {
            queryParameters = queryParameters.set('qtyDropped', <any>qtyDropped);
        }
        if (singleton !== undefined && singleton !== null) {
            queryParameters = queryParameters.set('singleton', <any>singleton);
        }
        if (sequence !== undefined && sequence !== null) {
            queryParameters = queryParameters.set('sequence', <any>sequence);
        }
        if (containerSequence !== undefined && containerSequence !== null) {
            queryParameters = queryParameters.set('containerSequence', <any>containerSequence);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<KillItem>>(`${this.basePath}/ws/v1/common/kill_item`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get kill victims
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param killID Kill ID selector
     * @param allianceID Kill victim alliance ID selector
     * @param killCharacterID Kill victim character ID selector
     * @param killCorporationID Kill victim corporation ID selector
     * @param damageTaken Kill victim damage taken selector
     * @param factionID Kill victim faction ID selector
     * @param shipTypeID Kill victim ship type ID selector
     * @param x Kill X position selector
     * @param y Kill Y position selector
     * @param z Kill Z position selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getKillVictims(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, killID?: string, allianceID?: string, killCharacterID?: string, killCorporationID?: string, damageTaken?: string, factionID?: string, shipTypeID?: string, x?: string, y?: string, z?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<KillVictim>>;
    public getKillVictims(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, killID?: string, allianceID?: string, killCharacterID?: string, killCorporationID?: string, damageTaken?: string, factionID?: string, shipTypeID?: string, x?: string, y?: string, z?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<KillVictim>>>;
    public getKillVictims(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, killID?: string, allianceID?: string, killCharacterID?: string, killCorporationID?: string, damageTaken?: string, factionID?: string, shipTypeID?: string, x?: string, y?: string, z?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<KillVictim>>>;
    public getKillVictims(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, killID?: string, allianceID?: string, killCharacterID?: string, killCorporationID?: string, damageTaken?: string, factionID?: string, shipTypeID?: string, x?: string, y?: string, z?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getKillVictims.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getKillVictims.');
        }















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (killID !== undefined && killID !== null) {
            queryParameters = queryParameters.set('killID', <any>killID);
        }
        if (allianceID !== undefined && allianceID !== null) {
            queryParameters = queryParameters.set('allianceID', <any>allianceID);
        }
        if (killCharacterID !== undefined && killCharacterID !== null) {
            queryParameters = queryParameters.set('killCharacterID', <any>killCharacterID);
        }
        if (killCorporationID !== undefined && killCorporationID !== null) {
            queryParameters = queryParameters.set('killCorporationID', <any>killCorporationID);
        }
        if (damageTaken !== undefined && damageTaken !== null) {
            queryParameters = queryParameters.set('damageTaken', <any>damageTaken);
        }
        if (factionID !== undefined && factionID !== null) {
            queryParameters = queryParameters.set('factionID', <any>factionID);
        }
        if (shipTypeID !== undefined && shipTypeID !== null) {
            queryParameters = queryParameters.set('shipTypeID', <any>shipTypeID);
        }
        if (x !== undefined && x !== null) {
            queryParameters = queryParameters.set('x', <any>x);
        }
        if (y !== undefined && y !== null) {
            queryParameters = queryParameters.set('y', <any>y);
        }
        if (z !== undefined && z !== null) {
            queryParameters = queryParameters.set('z', <any>z);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<KillVictim>>(`${this.basePath}/ws/v1/common/kill_victim`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get kills
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param killID Kill ID selector
     * @param killTime Kill time selector
     * @param moonID Kill moon ID selector
     * @param solarSystemID Kill solar system ID selector
     * @param warID War ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getKills(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, killID?: string, killTime?: string, moonID?: string, solarSystemID?: string, warID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Kill>>;
    public getKills(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, killID?: string, killTime?: string, moonID?: string, solarSystemID?: string, warID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Kill>>>;
    public getKills(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, killID?: string, killTime?: string, moonID?: string, solarSystemID?: string, warID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Kill>>>;
    public getKills(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, killID?: string, killTime?: string, moonID?: string, solarSystemID?: string, warID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getKills.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getKills.');
        }










        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (killID !== undefined && killID !== null) {
            queryParameters = queryParameters.set('killID', <any>killID);
        }
        if (killTime !== undefined && killTime !== null) {
            queryParameters = queryParameters.set('killTime', <any>killTime);
        }
        if (moonID !== undefined && moonID !== null) {
            queryParameters = queryParameters.set('moonID', <any>moonID);
        }
        if (solarSystemID !== undefined && solarSystemID !== null) {
            queryParameters = queryParameters.set('solarSystemID', <any>solarSystemID);
        }
        if (warID !== undefined && warID !== null) {
            queryParameters = queryParameters.set('warID', <any>warID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Kill>>(`${this.basePath}/ws/v1/common/kill`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get locations
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param itemID Location item ID selector
     * @param itemName Location item name selector
     * @param x Location X position selector
     * @param y Location Y position selector
     * @param z Location Z position selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLocations(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, itemID?: string, itemName?: string, x?: string, y?: string, z?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Location>>;
    public getLocations(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, itemID?: string, itemName?: string, x?: string, y?: string, z?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Location>>>;
    public getLocations(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, itemID?: string, itemName?: string, x?: string, y?: string, z?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Location>>>;
    public getLocations(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, itemID?: string, itemName?: string, x?: string, y?: string, z?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getLocations.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getLocations.');
        }










        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (itemID !== undefined && itemID !== null) {
            queryParameters = queryParameters.set('itemID', <any>itemID);
        }
        if (itemName !== undefined && itemName !== null) {
            queryParameters = queryParameters.set('itemName', <any>itemName);
        }
        if (x !== undefined && x !== null) {
            queryParameters = queryParameters.set('x', <any>x);
        }
        if (y !== undefined && y !== null) {
            queryParameters = queryParameters.set('y', <any>y);
        }
        if (z !== undefined && z !== null) {
            queryParameters = queryParameters.set('z', <any>z);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Location>>(`${this.basePath}/ws/v1/common/location`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get market orders
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param orderID Market order ID selector
     * @param walletDivision Market order wallet division selector
     * @param bid Market order bid indicator selector
     * @param charID Market order character ID selector
     * @param duration Market order duration selector
     * @param escrow Market order escrow selector
     * @param issued Market order issue date selector
     * @param issuedBy Market order issued by selector
     * @param minVolume Market order min volume selector
     * @param orderState Market order state selector
     * @param price Market order price selector
     * @param orderRange Market order range selector
     * @param typeID Market order type ID selector
     * @param volEntered Market order volume entered selector
     * @param volRemaining Market order volume remaining selector
     * @param regionID Market order region ID selector
     * @param locationID Market order location ID selector
     * @param isCorp Market order is corporation selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMarketOrders(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, orderID?: string, walletDivision?: string, bid?: string, charID?: string, duration?: string, escrow?: string, issued?: string, issuedBy?: string, minVolume?: string, orderState?: string, price?: string, orderRange?: string, typeID?: string, volEntered?: string, volRemaining?: string, regionID?: string, locationID?: string, isCorp?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MarketOrder>>;
    public getMarketOrders(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, orderID?: string, walletDivision?: string, bid?: string, charID?: string, duration?: string, escrow?: string, issued?: string, issuedBy?: string, minVolume?: string, orderState?: string, price?: string, orderRange?: string, typeID?: string, volEntered?: string, volRemaining?: string, regionID?: string, locationID?: string, isCorp?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MarketOrder>>>;
    public getMarketOrders(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, orderID?: string, walletDivision?: string, bid?: string, charID?: string, duration?: string, escrow?: string, issued?: string, issuedBy?: string, minVolume?: string, orderState?: string, price?: string, orderRange?: string, typeID?: string, volEntered?: string, volRemaining?: string, regionID?: string, locationID?: string, isCorp?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MarketOrder>>>;
    public getMarketOrders(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, orderID?: string, walletDivision?: string, bid?: string, charID?: string, duration?: string, escrow?: string, issued?: string, issuedBy?: string, minVolume?: string, orderState?: string, price?: string, orderRange?: string, typeID?: string, volEntered?: string, volRemaining?: string, regionID?: string, locationID?: string, isCorp?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getMarketOrders.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getMarketOrders.');
        }























        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (orderID !== undefined && orderID !== null) {
            queryParameters = queryParameters.set('orderID', <any>orderID);
        }
        if (walletDivision !== undefined && walletDivision !== null) {
            queryParameters = queryParameters.set('walletDivision', <any>walletDivision);
        }
        if (bid !== undefined && bid !== null) {
            queryParameters = queryParameters.set('bid', <any>bid);
        }
        if (charID !== undefined && charID !== null) {
            queryParameters = queryParameters.set('charID', <any>charID);
        }
        if (duration !== undefined && duration !== null) {
            queryParameters = queryParameters.set('duration', <any>duration);
        }
        if (escrow !== undefined && escrow !== null) {
            queryParameters = queryParameters.set('escrow', <any>escrow);
        }
        if (issued !== undefined && issued !== null) {
            queryParameters = queryParameters.set('issued', <any>issued);
        }
        if (issuedBy !== undefined && issuedBy !== null) {
            queryParameters = queryParameters.set('issuedBy', <any>issuedBy);
        }
        if (minVolume !== undefined && minVolume !== null) {
            queryParameters = queryParameters.set('minVolume', <any>minVolume);
        }
        if (orderState !== undefined && orderState !== null) {
            queryParameters = queryParameters.set('orderState', <any>orderState);
        }
        if (price !== undefined && price !== null) {
            queryParameters = queryParameters.set('price', <any>price);
        }
        if (orderRange !== undefined && orderRange !== null) {
            queryParameters = queryParameters.set('orderRange', <any>orderRange);
        }
        if (typeID !== undefined && typeID !== null) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (volEntered !== undefined && volEntered !== null) {
            queryParameters = queryParameters.set('volEntered', <any>volEntered);
        }
        if (volRemaining !== undefined && volRemaining !== null) {
            queryParameters = queryParameters.set('volRemaining', <any>volRemaining);
        }
        if (regionID !== undefined && regionID !== null) {
            queryParameters = queryParameters.set('regionID', <any>regionID);
        }
        if (locationID !== undefined && locationID !== null) {
            queryParameters = queryParameters.set('locationID', <any>locationID);
        }
        if (isCorp !== undefined && isCorp !== null) {
            queryParameters = queryParameters.set('isCorp', <any>isCorp);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MarketOrder>>(`${this.basePath}/ws/v1/common/market_order`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get standings)
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param standingEntity Standing entity selector
     * @param fromID Standing from ID selector
     * @param standing Standing value selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStandings(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, standingEntity?: string, fromID?: string, standing?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Standing>>;
    public getStandings(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, standingEntity?: string, fromID?: string, standing?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Standing>>>;
    public getStandings(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, standingEntity?: string, fromID?: string, standing?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Standing>>>;
    public getStandings(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, standingEntity?: string, fromID?: string, standing?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getStandings.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getStandings.');
        }








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (standingEntity !== undefined && standingEntity !== null) {
            queryParameters = queryParameters.set('standingEntity', <any>standingEntity);
        }
        if (fromID !== undefined && fromID !== null) {
            queryParameters = queryParameters.set('fromID', <any>fromID);
        }
        if (standing !== undefined && standing !== null) {
            queryParameters = queryParameters.set('standing', <any>standing);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Standing>>(`${this.basePath}/ws/v1/common/standing`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get wallet transactions
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param division Wallet division selector
     * @param transactionID Transaction ID selector
     * @param date Transaction date selector
     * @param quantity Transaction quantity selector
     * @param typeID Transaction type ID selector
     * @param price Transaction price selector
     * @param clientID Transaction client ID selector
     * @param locationID Transaction location ID selector
     * @param isBuy Transaction isBuy selector
     * @param isPersonal Transaction isPersonal selector
     * @param journalTransactionID Journal transaction ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getWalletTransactions(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, division?: string, transactionID?: string, date?: string, quantity?: string, typeID?: string, price?: string, clientID?: string, locationID?: string, isBuy?: string, isPersonal?: string, journalTransactionID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<WalletTransaction>>;
    public getWalletTransactions(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, division?: string, transactionID?: string, date?: string, quantity?: string, typeID?: string, price?: string, clientID?: string, locationID?: string, isBuy?: string, isPersonal?: string, journalTransactionID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<WalletTransaction>>>;
    public getWalletTransactions(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, division?: string, transactionID?: string, date?: string, quantity?: string, typeID?: string, price?: string, clientID?: string, locationID?: string, isBuy?: string, isPersonal?: string, journalTransactionID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<WalletTransaction>>>;
    public getWalletTransactions(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, division?: string, transactionID?: string, date?: string, quantity?: string, typeID?: string, price?: string, clientID?: string, locationID?: string, isBuy?: string, isPersonal?: string, journalTransactionID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getWalletTransactions.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getWalletTransactions.');
        }
















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (division !== undefined && division !== null) {
            queryParameters = queryParameters.set('division', <any>division);
        }
        if (transactionID !== undefined && transactionID !== null) {
            queryParameters = queryParameters.set('transactionID', <any>transactionID);
        }
        if (date !== undefined && date !== null) {
            queryParameters = queryParameters.set('date', <any>date);
        }
        if (quantity !== undefined && quantity !== null) {
            queryParameters = queryParameters.set('quantity', <any>quantity);
        }
        if (typeID !== undefined && typeID !== null) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (price !== undefined && price !== null) {
            queryParameters = queryParameters.set('price', <any>price);
        }
        if (clientID !== undefined && clientID !== null) {
            queryParameters = queryParameters.set('clientID', <any>clientID);
        }
        if (locationID !== undefined && locationID !== null) {
            queryParameters = queryParameters.set('locationID', <any>locationID);
        }
        if (isBuy !== undefined && isBuy !== null) {
            queryParameters = queryParameters.set('isBuy', <any>isBuy);
        }
        if (isPersonal !== undefined && isPersonal !== null) {
            queryParameters = queryParameters.set('isPersonal', <any>isPersonal);
        }
        if (journalTransactionID !== undefined && journalTransactionID !== null) {
            queryParameters = queryParameters.set('journalTransactionID', <any>journalTransactionID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<WalletTransaction>>(`${this.basePath}/ws/v1/common/wallet_transaction`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
