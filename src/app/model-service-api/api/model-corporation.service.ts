/**
 * EveKit Model API Server
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { ContainerLog } from '../model/containerLog';
import { CorporationMedal } from '../model/corporationMedal';
import { CorporationMemberMedal } from '../model/corporationMemberMedal';
import { CorporationSheet } from '../model/corporationSheet';
import { CorporationTitle } from '../model/corporationTitle';
import { CorporationTitleRole } from '../model/corporationTitleRole';
import { CustomsOffice } from '../model/customsOffice';
import { Division } from '../model/division';
import { Facility } from '../model/facility';
import { Fuel } from '../model/fuel';
import { Member } from '../model/member';
import { MemberLimit } from '../model/memberLimit';
import { MemberRole } from '../model/memberRole';
import { MemberRoleHistory } from '../model/memberRoleHistory';
import { MemberTitle } from '../model/memberTitle';
import { MemberTracking } from '../model/memberTracking';
import { MiningExtraction } from '../model/miningExtraction';
import { MiningObservation } from '../model/miningObservation';
import { MiningObserver } from '../model/miningObserver';
import { ServiceError } from '../model/serviceError';
import { Shareholder } from '../model/shareholder';
import { Starbase } from '../model/starbase';
import { Structure } from '../model/structure';
import { StructureService } from '../model/structureService';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ModelCorporationService {

    protected basePath = 'https://evekit-model.orbital.enterprises//api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Get container log records
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param logTime Corporation container log time selector
     * @param action Corporation container log action selector
     * @param characterID Corporation container log character ID selector
     * @param locationFlag Corporation container log location flag selector
     * @param containerID Corporation container log container ID selector
     * @param containerTypeID Corporation container log container type ID selector
     * @param locationID Corporation container log location ID selector
     * @param newConfiguration Corporation container log new configuration selector
     * @param oldConfiguration Corporation container log old configuration selector
     * @param passwordType Corporation container log password type selector
     * @param quantity Corporation container log quantity selector
     * @param typeID Corporation container log type ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getContainerLogs(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, logTime?: string, action?: string, characterID?: string, locationFlag?: string, containerID?: string, containerTypeID?: string, locationID?: string, newConfiguration?: string, oldConfiguration?: string, passwordType?: string, quantity?: string, typeID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ContainerLog>>;
    public getContainerLogs(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, logTime?: string, action?: string, characterID?: string, locationFlag?: string, containerID?: string, containerTypeID?: string, locationID?: string, newConfiguration?: string, oldConfiguration?: string, passwordType?: string, quantity?: string, typeID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ContainerLog>>>;
    public getContainerLogs(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, logTime?: string, action?: string, characterID?: string, locationFlag?: string, containerID?: string, containerTypeID?: string, locationID?: string, newConfiguration?: string, oldConfiguration?: string, passwordType?: string, quantity?: string, typeID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ContainerLog>>>;
    public getContainerLogs(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, logTime?: string, action?: string, characterID?: string, locationFlag?: string, containerID?: string, containerTypeID?: string, locationID?: string, newConfiguration?: string, oldConfiguration?: string, passwordType?: string, quantity?: string, typeID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getContainerLogs.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getContainerLogs.');
        }

















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (logTime !== undefined && logTime !== null) {
            queryParameters = queryParameters.set('logTime', <any>logTime);
        }
        if (action !== undefined && action !== null) {
            queryParameters = queryParameters.set('action', <any>action);
        }
        if (characterID !== undefined && characterID !== null) {
            queryParameters = queryParameters.set('characterID', <any>characterID);
        }
        if (locationFlag !== undefined && locationFlag !== null) {
            queryParameters = queryParameters.set('locationFlag', <any>locationFlag);
        }
        if (containerID !== undefined && containerID !== null) {
            queryParameters = queryParameters.set('containerID', <any>containerID);
        }
        if (containerTypeID !== undefined && containerTypeID !== null) {
            queryParameters = queryParameters.set('containerTypeID', <any>containerTypeID);
        }
        if (locationID !== undefined && locationID !== null) {
            queryParameters = queryParameters.set('locationID', <any>locationID);
        }
        if (newConfiguration !== undefined && newConfiguration !== null) {
            queryParameters = queryParameters.set('newConfiguration', <any>newConfiguration);
        }
        if (oldConfiguration !== undefined && oldConfiguration !== null) {
            queryParameters = queryParameters.set('oldConfiguration', <any>oldConfiguration);
        }
        if (passwordType !== undefined && passwordType !== null) {
            queryParameters = queryParameters.set('passwordType', <any>passwordType);
        }
        if (quantity !== undefined && quantity !== null) {
            queryParameters = queryParameters.set('quantity', <any>quantity);
        }
        if (typeID !== undefined && typeID !== null) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ContainerLog>>(`${this.basePath}/ws/v1/corp/container_log`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get corporation medals
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param medalID Corporation medal ID selector
     * @param description Corporation medal description selector
     * @param title Corporation medal title selector
     * @param created Corporation medal created date selector
     * @param creatorID Corporation medal creator ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCorporationMedals(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, medalID?: string, description?: string, title?: string, created?: string, creatorID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CorporationMedal>>;
    public getCorporationMedals(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, medalID?: string, description?: string, title?: string, created?: string, creatorID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CorporationMedal>>>;
    public getCorporationMedals(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, medalID?: string, description?: string, title?: string, created?: string, creatorID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CorporationMedal>>>;
    public getCorporationMedals(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, medalID?: string, description?: string, title?: string, created?: string, creatorID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getCorporationMedals.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getCorporationMedals.');
        }










        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (medalID !== undefined && medalID !== null) {
            queryParameters = queryParameters.set('medalID', <any>medalID);
        }
        if (description !== undefined && description !== null) {
            queryParameters = queryParameters.set('description', <any>description);
        }
        if (title !== undefined && title !== null) {
            queryParameters = queryParameters.set('title', <any>title);
        }
        if (created !== undefined && created !== null) {
            queryParameters = queryParameters.set('created', <any>created);
        }
        if (creatorID !== undefined && creatorID !== null) {
            queryParameters = queryParameters.set('creatorID', <any>creatorID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CorporationMedal>>(`${this.basePath}/ws/v1/corp/medal`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get corporation sheet
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param allianceID Corporation alliance ID selector
     * @param ceoID Corporation CEO ID selector
     * @param corporationID Corporation ID selector
     * @param corporationName Corporation name selector
     * @param description Corporation description selector
     * @param memberCount Corporation member count selector
     * @param shares Corporation shares selector
     * @param stationID Corporation station ID selector
     * @param taxRate Corporation tax rate selector
     * @param ticker Corporation ticker selector
     * @param url Corporation URL selector
     * @param dateFounded Corporation founding date selector
     * @param creatorID Corporation creator ID selector
     * @param factionID Corporation faction ID selector
     * @param px64x64 Corporation 64x64 image URL selector
     * @param px128x128 Corporation 128x128 image URL selector
     * @param px256x256 Corporation 256x256 image URL selector
     * @param warEligible Corporation war eligible selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCorporationSheet(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, allianceID?: string, ceoID?: string, corporationID?: string, corporationName?: string, description?: string, memberCount?: string, shares?: string, stationID?: string, taxRate?: string, ticker?: string, url?: string, dateFounded?: string, creatorID?: string, factionID?: string, px64x64?: string, px128x128?: string, px256x256?: string, warEligible?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CorporationSheet>>;
    public getCorporationSheet(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, allianceID?: string, ceoID?: string, corporationID?: string, corporationName?: string, description?: string, memberCount?: string, shares?: string, stationID?: string, taxRate?: string, ticker?: string, url?: string, dateFounded?: string, creatorID?: string, factionID?: string, px64x64?: string, px128x128?: string, px256x256?: string, warEligible?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CorporationSheet>>>;
    public getCorporationSheet(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, allianceID?: string, ceoID?: string, corporationID?: string, corporationName?: string, description?: string, memberCount?: string, shares?: string, stationID?: string, taxRate?: string, ticker?: string, url?: string, dateFounded?: string, creatorID?: string, factionID?: string, px64x64?: string, px128x128?: string, px256x256?: string, warEligible?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CorporationSheet>>>;
    public getCorporationSheet(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, allianceID?: string, ceoID?: string, corporationID?: string, corporationName?: string, description?: string, memberCount?: string, shares?: string, stationID?: string, taxRate?: string, ticker?: string, url?: string, dateFounded?: string, creatorID?: string, factionID?: string, px64x64?: string, px128x128?: string, px256x256?: string, warEligible?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getCorporationSheet.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getCorporationSheet.');
        }























        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (allianceID !== undefined && allianceID !== null) {
            queryParameters = queryParameters.set('allianceID', <any>allianceID);
        }
        if (ceoID !== undefined && ceoID !== null) {
            queryParameters = queryParameters.set('ceoID', <any>ceoID);
        }
        if (corporationID !== undefined && corporationID !== null) {
            queryParameters = queryParameters.set('corporationID', <any>corporationID);
        }
        if (corporationName !== undefined && corporationName !== null) {
            queryParameters = queryParameters.set('corporationName', <any>corporationName);
        }
        if (description !== undefined && description !== null) {
            queryParameters = queryParameters.set('description', <any>description);
        }
        if (memberCount !== undefined && memberCount !== null) {
            queryParameters = queryParameters.set('memberCount', <any>memberCount);
        }
        if (shares !== undefined && shares !== null) {
            queryParameters = queryParameters.set('shares', <any>shares);
        }
        if (stationID !== undefined && stationID !== null) {
            queryParameters = queryParameters.set('stationID', <any>stationID);
        }
        if (taxRate !== undefined && taxRate !== null) {
            queryParameters = queryParameters.set('taxRate', <any>taxRate);
        }
        if (ticker !== undefined && ticker !== null) {
            queryParameters = queryParameters.set('ticker', <any>ticker);
        }
        if (url !== undefined && url !== null) {
            queryParameters = queryParameters.set('url', <any>url);
        }
        if (dateFounded !== undefined && dateFounded !== null) {
            queryParameters = queryParameters.set('dateFounded', <any>dateFounded);
        }
        if (creatorID !== undefined && creatorID !== null) {
            queryParameters = queryParameters.set('creatorID', <any>creatorID);
        }
        if (factionID !== undefined && factionID !== null) {
            queryParameters = queryParameters.set('factionID', <any>factionID);
        }
        if (px64x64 !== undefined && px64x64 !== null) {
            queryParameters = queryParameters.set('px64x64', <any>px64x64);
        }
        if (px128x128 !== undefined && px128x128 !== null) {
            queryParameters = queryParameters.set('px128x128', <any>px128x128);
        }
        if (px256x256 !== undefined && px256x256 !== null) {
            queryParameters = queryParameters.set('px256x256', <any>px256x256);
        }
        if (warEligible !== undefined && warEligible !== null) {
            queryParameters = queryParameters.set('warEligible', <any>warEligible);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CorporationSheet>>(`${this.basePath}/ws/v1/corp/sheet`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get corporation title roles
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param titleID Corporation title role ID selector
     * @param roleName Corporation title role name selector
     * @param grantable Corporation title role grantable selector
     * @param atHQ Corporation title role at HQ selector
     * @param atBase Corporation title role at base selector
     * @param atOther Corporation title role at other selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCorporationTitleRoles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, titleID?: string, roleName?: string, grantable?: string, atHQ?: string, atBase?: string, atOther?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CorporationTitleRole>>;
    public getCorporationTitleRoles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, titleID?: string, roleName?: string, grantable?: string, atHQ?: string, atBase?: string, atOther?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CorporationTitleRole>>>;
    public getCorporationTitleRoles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, titleID?: string, roleName?: string, grantable?: string, atHQ?: string, atBase?: string, atOther?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CorporationTitleRole>>>;
    public getCorporationTitleRoles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, titleID?: string, roleName?: string, grantable?: string, atHQ?: string, atBase?: string, atOther?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getCorporationTitleRoles.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getCorporationTitleRoles.');
        }











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (titleID !== undefined && titleID !== null) {
            queryParameters = queryParameters.set('titleID', <any>titleID);
        }
        if (roleName !== undefined && roleName !== null) {
            queryParameters = queryParameters.set('roleName', <any>roleName);
        }
        if (grantable !== undefined && grantable !== null) {
            queryParameters = queryParameters.set('grantable', <any>grantable);
        }
        if (atHQ !== undefined && atHQ !== null) {
            queryParameters = queryParameters.set('atHQ', <any>atHQ);
        }
        if (atBase !== undefined && atBase !== null) {
            queryParameters = queryParameters.set('atBase', <any>atBase);
        }
        if (atOther !== undefined && atOther !== null) {
            queryParameters = queryParameters.set('atOther', <any>atOther);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CorporationTitleRole>>(`${this.basePath}/ws/v1/corp/title_role`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get corporation titles
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param titleID Corporation title ID selector
     * @param titleName Corporation title name selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCorporationTitles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, titleID?: string, titleName?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CorporationTitle>>;
    public getCorporationTitles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, titleID?: string, titleName?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CorporationTitle>>>;
    public getCorporationTitles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, titleID?: string, titleName?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CorporationTitle>>>;
    public getCorporationTitles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, titleID?: string, titleName?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getCorporationTitles.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getCorporationTitles.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (titleID !== undefined && titleID !== null) {
            queryParameters = queryParameters.set('titleID', <any>titleID);
        }
        if (titleName !== undefined && titleName !== null) {
            queryParameters = queryParameters.set('titleName', <any>titleName);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CorporationTitle>>(`${this.basePath}/ws/v1/corp/title`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get corporation customs offices
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param officeID Customs office ID selector
     * @param solarSystemID Customs office solar system ID selector
     * @param reinforceExitStart Customs office reinforce exit timer start selector
     * @param reinforceExitEnd Customs office reinforce exit timer end selector
     * @param allowAlliance Customs office allow alliance selector
     * @param allowStandings Customs office allow standings selector
     * @param standingLevel Customs office standing level selector
     * @param taxRateAlliance Customs office tax rate alliance selector
     * @param taxRateCorp Customs office tax rate corporation selector
     * @param taxRateStandingExcellent Customs office tax rate standing excellent selector
     * @param taxRateStandingGood Customs office tax rate standing good selector
     * @param taxRateStandingNeutral Customs office tax rate standing neutral selector
     * @param taxRateStandingBad Customs office tax rate standing bad selector
     * @param taxRateStandingTerrible Customs office tax rate standing terrible selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCustomsOffices(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, officeID?: string, solarSystemID?: string, reinforceExitStart?: string, reinforceExitEnd?: string, allowAlliance?: string, allowStandings?: string, standingLevel?: string, taxRateAlliance?: string, taxRateCorp?: string, taxRateStandingExcellent?: string, taxRateStandingGood?: string, taxRateStandingNeutral?: string, taxRateStandingBad?: string, taxRateStandingTerrible?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CustomsOffice>>;
    public getCustomsOffices(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, officeID?: string, solarSystemID?: string, reinforceExitStart?: string, reinforceExitEnd?: string, allowAlliance?: string, allowStandings?: string, standingLevel?: string, taxRateAlliance?: string, taxRateCorp?: string, taxRateStandingExcellent?: string, taxRateStandingGood?: string, taxRateStandingNeutral?: string, taxRateStandingBad?: string, taxRateStandingTerrible?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CustomsOffice>>>;
    public getCustomsOffices(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, officeID?: string, solarSystemID?: string, reinforceExitStart?: string, reinforceExitEnd?: string, allowAlliance?: string, allowStandings?: string, standingLevel?: string, taxRateAlliance?: string, taxRateCorp?: string, taxRateStandingExcellent?: string, taxRateStandingGood?: string, taxRateStandingNeutral?: string, taxRateStandingBad?: string, taxRateStandingTerrible?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CustomsOffice>>>;
    public getCustomsOffices(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, officeID?: string, solarSystemID?: string, reinforceExitStart?: string, reinforceExitEnd?: string, allowAlliance?: string, allowStandings?: string, standingLevel?: string, taxRateAlliance?: string, taxRateCorp?: string, taxRateStandingExcellent?: string, taxRateStandingGood?: string, taxRateStandingNeutral?: string, taxRateStandingBad?: string, taxRateStandingTerrible?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getCustomsOffices.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getCustomsOffices.');
        }



















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (officeID !== undefined && officeID !== null) {
            queryParameters = queryParameters.set('officeID', <any>officeID);
        }
        if (solarSystemID !== undefined && solarSystemID !== null) {
            queryParameters = queryParameters.set('solarSystemID', <any>solarSystemID);
        }
        if (reinforceExitStart !== undefined && reinforceExitStart !== null) {
            queryParameters = queryParameters.set('reinforceExitStart', <any>reinforceExitStart);
        }
        if (reinforceExitEnd !== undefined && reinforceExitEnd !== null) {
            queryParameters = queryParameters.set('reinforceExitEnd', <any>reinforceExitEnd);
        }
        if (allowAlliance !== undefined && allowAlliance !== null) {
            queryParameters = queryParameters.set('allowAlliance', <any>allowAlliance);
        }
        if (allowStandings !== undefined && allowStandings !== null) {
            queryParameters = queryParameters.set('allowStandings', <any>allowStandings);
        }
        if (standingLevel !== undefined && standingLevel !== null) {
            queryParameters = queryParameters.set('standingLevel', <any>standingLevel);
        }
        if (taxRateAlliance !== undefined && taxRateAlliance !== null) {
            queryParameters = queryParameters.set('taxRateAlliance', <any>taxRateAlliance);
        }
        if (taxRateCorp !== undefined && taxRateCorp !== null) {
            queryParameters = queryParameters.set('taxRateCorp', <any>taxRateCorp);
        }
        if (taxRateStandingExcellent !== undefined && taxRateStandingExcellent !== null) {
            queryParameters = queryParameters.set('taxRateStandingExcellent', <any>taxRateStandingExcellent);
        }
        if (taxRateStandingGood !== undefined && taxRateStandingGood !== null) {
            queryParameters = queryParameters.set('taxRateStandingGood', <any>taxRateStandingGood);
        }
        if (taxRateStandingNeutral !== undefined && taxRateStandingNeutral !== null) {
            queryParameters = queryParameters.set('taxRateStandingNeutral', <any>taxRateStandingNeutral);
        }
        if (taxRateStandingBad !== undefined && taxRateStandingBad !== null) {
            queryParameters = queryParameters.set('taxRateStandingBad', <any>taxRateStandingBad);
        }
        if (taxRateStandingTerrible !== undefined && taxRateStandingTerrible !== null) {
            queryParameters = queryParameters.set('taxRateStandingTerrible', <any>taxRateStandingTerrible);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CustomsOffice>>(`${this.basePath}/ws/v1/corp/customs_office`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get corporation divisions
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param wallet Division wallet indicator selector
     * @param division Division ID selector
     * @param name Division name selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDivisions(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, wallet?: string, division?: string, name?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Division>>;
    public getDivisions(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, wallet?: string, division?: string, name?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Division>>>;
    public getDivisions(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, wallet?: string, division?: string, name?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Division>>>;
    public getDivisions(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, wallet?: string, division?: string, name?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getDivisions.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getDivisions.');
        }








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (wallet !== undefined && wallet !== null) {
            queryParameters = queryParameters.set('wallet', <any>wallet);
        }
        if (division !== undefined && division !== null) {
            queryParameters = queryParameters.set('division', <any>division);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Division>>(`${this.basePath}/ws/v1/corp/division`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get corporation facilities
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param facilityID Facility ID selector
     * @param typeID Facility type ID selector
     * @param solarSystemID Facility solar system ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFacilities(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, facilityID?: string, typeID?: string, solarSystemID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Facility>>;
    public getFacilities(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, facilityID?: string, typeID?: string, solarSystemID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Facility>>>;
    public getFacilities(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, facilityID?: string, typeID?: string, solarSystemID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Facility>>>;
    public getFacilities(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, facilityID?: string, typeID?: string, solarSystemID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getFacilities.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getFacilities.');
        }








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (facilityID !== undefined && facilityID !== null) {
            queryParameters = queryParameters.set('facilityID', <any>facilityID);
        }
        if (typeID !== undefined && typeID !== null) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (solarSystemID !== undefined && solarSystemID !== null) {
            queryParameters = queryParameters.set('solarSystemID', <any>solarSystemID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Facility>>(`${this.basePath}/ws/v1/corp/facility`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get corporation starbase fuel levels
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param starbaseID Fuel starbase ID selector
     * @param typeID Fuel type ID selector
     * @param quantity Fuel quantity selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFuel(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, starbaseID?: string, typeID?: string, quantity?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Fuel>>;
    public getFuel(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, starbaseID?: string, typeID?: string, quantity?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Fuel>>>;
    public getFuel(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, starbaseID?: string, typeID?: string, quantity?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Fuel>>>;
    public getFuel(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, starbaseID?: string, typeID?: string, quantity?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getFuel.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getFuel.');
        }








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (starbaseID !== undefined && starbaseID !== null) {
            queryParameters = queryParameters.set('starbaseID', <any>starbaseID);
        }
        if (typeID !== undefined && typeID !== null) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (quantity !== undefined && quantity !== null) {
            queryParameters = queryParameters.set('quantity', <any>quantity);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Fuel>>(`${this.basePath}/ws/v1/corp/fuel`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get corporation member limit information
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param memberLimit Corporation member limit selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberLimit(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, memberLimit?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MemberLimit>>;
    public getMemberLimit(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, memberLimit?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MemberLimit>>>;
    public getMemberLimit(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, memberLimit?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MemberLimit>>>;
    public getMemberLimit(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, memberLimit?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getMemberLimit.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getMemberLimit.');
        }






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (memberLimit !== undefined && memberLimit !== null) {
            queryParameters = queryParameters.set('memberLimit', <any>memberLimit);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MemberLimit>>(`${this.basePath}/ws/v1/corp/member_limit`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get medals awarded to corporation members
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param medalID Member medal ID selector
     * @param characterID Member medal character ID selector
     * @param issued Member medal issued date selector
     * @param issuerID Member medal issuer ID selector
     * @param reason Member medal reason selector
     * @param status Member medal status selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberMedals(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, medalID?: string, characterID?: string, issued?: string, issuerID?: string, reason?: string, status?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CorporationMemberMedal>>;
    public getMemberMedals(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, medalID?: string, characterID?: string, issued?: string, issuerID?: string, reason?: string, status?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CorporationMemberMedal>>>;
    public getMemberMedals(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, medalID?: string, characterID?: string, issued?: string, issuerID?: string, reason?: string, status?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CorporationMemberMedal>>>;
    public getMemberMedals(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, medalID?: string, characterID?: string, issued?: string, issuerID?: string, reason?: string, status?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getMemberMedals.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getMemberMedals.');
        }











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (medalID !== undefined && medalID !== null) {
            queryParameters = queryParameters.set('medalID', <any>medalID);
        }
        if (characterID !== undefined && characterID !== null) {
            queryParameters = queryParameters.set('characterID', <any>characterID);
        }
        if (issued !== undefined && issued !== null) {
            queryParameters = queryParameters.set('issued', <any>issued);
        }
        if (issuerID !== undefined && issuerID !== null) {
            queryParameters = queryParameters.set('issuerID', <any>issuerID);
        }
        if (reason !== undefined && reason !== null) {
            queryParameters = queryParameters.set('reason', <any>reason);
        }
        if (status !== undefined && status !== null) {
            queryParameters = queryParameters.set('status', <any>status);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CorporationMemberMedal>>(`${this.basePath}/ws/v1/corp/member_medal`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get corporation member role history entries
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param characterID Member role history character ID selector
     * @param changedAt Member role history change time selector
     * @param issuerID Member role history issuer ID selector
     * @param roleType Member role history role type selector
     * @param roleName Member role history roel name selector
     * @param old Member role history is old selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberRoleHistory(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, changedAt?: string, issuerID?: string, roleType?: string, roleName?: string, old?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MemberRoleHistory>>;
    public getMemberRoleHistory(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, changedAt?: string, issuerID?: string, roleType?: string, roleName?: string, old?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MemberRoleHistory>>>;
    public getMemberRoleHistory(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, changedAt?: string, issuerID?: string, roleType?: string, roleName?: string, old?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MemberRoleHistory>>>;
    public getMemberRoleHistory(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, changedAt?: string, issuerID?: string, roleType?: string, roleName?: string, old?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getMemberRoleHistory.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getMemberRoleHistory.');
        }











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (characterID !== undefined && characterID !== null) {
            queryParameters = queryParameters.set('characterID', <any>characterID);
        }
        if (changedAt !== undefined && changedAt !== null) {
            queryParameters = queryParameters.set('changedAt', <any>changedAt);
        }
        if (issuerID !== undefined && issuerID !== null) {
            queryParameters = queryParameters.set('issuerID', <any>issuerID);
        }
        if (roleType !== undefined && roleType !== null) {
            queryParameters = queryParameters.set('roleType', <any>roleType);
        }
        if (roleName !== undefined && roleName !== null) {
            queryParameters = queryParameters.set('roleName', <any>roleName);
        }
        if (old !== undefined && old !== null) {
            queryParameters = queryParameters.set('old', <any>old);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MemberRoleHistory>>(`${this.basePath}/ws/v1/corp/member_role_history`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get corporation member roles
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param characterID Member role character ID selector
     * @param roleName Member role name selector
     * @param grantable Member role grantable selector
     * @param atHQ Member role at HQ selector
     * @param atBase Member role at base selector
     * @param atOther Member role at other selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberRoles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, roleName?: string, grantable?: string, atHQ?: string, atBase?: string, atOther?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MemberRole>>;
    public getMemberRoles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, roleName?: string, grantable?: string, atHQ?: string, atBase?: string, atOther?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MemberRole>>>;
    public getMemberRoles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, roleName?: string, grantable?: string, atHQ?: string, atBase?: string, atOther?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MemberRole>>>;
    public getMemberRoles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, roleName?: string, grantable?: string, atHQ?: string, atBase?: string, atOther?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getMemberRoles.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getMemberRoles.');
        }











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (characterID !== undefined && characterID !== null) {
            queryParameters = queryParameters.set('characterID', <any>characterID);
        }
        if (roleName !== undefined && roleName !== null) {
            queryParameters = queryParameters.set('roleName', <any>roleName);
        }
        if (grantable !== undefined && grantable !== null) {
            queryParameters = queryParameters.set('grantable', <any>grantable);
        }
        if (atHQ !== undefined && atHQ !== null) {
            queryParameters = queryParameters.set('atHQ', <any>atHQ);
        }
        if (atBase !== undefined && atBase !== null) {
            queryParameters = queryParameters.set('atBase', <any>atBase);
        }
        if (atOther !== undefined && atOther !== null) {
            queryParameters = queryParameters.set('atOther', <any>atOther);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MemberRole>>(`${this.basePath}/ws/v1/corp/member_role`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get corporation member titles
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param characterID Corporation member title character ID selector
     * @param titleID Corporation member title ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberTitles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, titleID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MemberTitle>>;
    public getMemberTitles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, titleID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MemberTitle>>>;
    public getMemberTitles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, titleID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MemberTitle>>>;
    public getMemberTitles(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, titleID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getMemberTitles.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getMemberTitles.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (characterID !== undefined && characterID !== null) {
            queryParameters = queryParameters.set('characterID', <any>characterID);
        }
        if (titleID !== undefined && titleID !== null) {
            queryParameters = queryParameters.set('titleID', <any>titleID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MemberTitle>>(`${this.basePath}/ws/v1/corp/member_title`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get member tracking information
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param characterID Member character ID selector
     * @param baseID Member base ID selector
     * @param locationID Member location ID selector
     * @param logoffDateTime Member logoff time selector
     * @param logonDateTime Member logon time selector
     * @param shipTypeID Member ship type ID selector
     * @param startDateTime Member start time selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberTracking(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, baseID?: string, locationID?: string, logoffDateTime?: string, logonDateTime?: string, shipTypeID?: string, startDateTime?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MemberTracking>>;
    public getMemberTracking(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, baseID?: string, locationID?: string, logoffDateTime?: string, logonDateTime?: string, shipTypeID?: string, startDateTime?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MemberTracking>>>;
    public getMemberTracking(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, baseID?: string, locationID?: string, logoffDateTime?: string, logonDateTime?: string, shipTypeID?: string, startDateTime?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MemberTracking>>>;
    public getMemberTracking(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, baseID?: string, locationID?: string, logoffDateTime?: string, logonDateTime?: string, shipTypeID?: string, startDateTime?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getMemberTracking.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getMemberTracking.');
        }












        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (characterID !== undefined && characterID !== null) {
            queryParameters = queryParameters.set('characterID', <any>characterID);
        }
        if (baseID !== undefined && baseID !== null) {
            queryParameters = queryParameters.set('baseID', <any>baseID);
        }
        if (locationID !== undefined && locationID !== null) {
            queryParameters = queryParameters.set('locationID', <any>locationID);
        }
        if (logoffDateTime !== undefined && logoffDateTime !== null) {
            queryParameters = queryParameters.set('logoffDateTime', <any>logoffDateTime);
        }
        if (logonDateTime !== undefined && logonDateTime !== null) {
            queryParameters = queryParameters.set('logonDateTime', <any>logonDateTime);
        }
        if (shipTypeID !== undefined && shipTypeID !== null) {
            queryParameters = queryParameters.set('shipTypeID', <any>shipTypeID);
        }
        if (startDateTime !== undefined && startDateTime !== null) {
            queryParameters = queryParameters.set('startDateTime', <any>startDateTime);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MemberTracking>>(`${this.basePath}/ws/v1/corp/member_tracking`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get corporation members
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param characterID Corporation character ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMembers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Member>>;
    public getMembers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Member>>>;
    public getMembers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Member>>>;
    public getMembers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, characterID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getMembers.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getMembers.');
        }






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (characterID !== undefined && characterID !== null) {
            queryParameters = queryParameters.set('characterID', <any>characterID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Member>>(`${this.basePath}/ws/v1/corp/members`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get mining extractions information
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param moonID Moon ID selector
     * @param structureID Structure ID selector
     * @param extractionStartTime Extraction start time selector
     * @param chunkArrivalTime Chunk arrival time selector
     * @param naturalDecayTime Natural decay time selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMiningExtractions(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, moonID?: string, structureID?: string, extractionStartTime?: string, chunkArrivalTime?: string, naturalDecayTime?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MiningExtraction>>;
    public getMiningExtractions(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, moonID?: string, structureID?: string, extractionStartTime?: string, chunkArrivalTime?: string, naturalDecayTime?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MiningExtraction>>>;
    public getMiningExtractions(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, moonID?: string, structureID?: string, extractionStartTime?: string, chunkArrivalTime?: string, naturalDecayTime?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MiningExtraction>>>;
    public getMiningExtractions(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, moonID?: string, structureID?: string, extractionStartTime?: string, chunkArrivalTime?: string, naturalDecayTime?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getMiningExtractions.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getMiningExtractions.');
        }










        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (moonID !== undefined && moonID !== null) {
            queryParameters = queryParameters.set('moonID', <any>moonID);
        }
        if (structureID !== undefined && structureID !== null) {
            queryParameters = queryParameters.set('structureID', <any>structureID);
        }
        if (extractionStartTime !== undefined && extractionStartTime !== null) {
            queryParameters = queryParameters.set('extractionStartTime', <any>extractionStartTime);
        }
        if (chunkArrivalTime !== undefined && chunkArrivalTime !== null) {
            queryParameters = queryParameters.set('chunkArrivalTime', <any>chunkArrivalTime);
        }
        if (naturalDecayTime !== undefined && naturalDecayTime !== null) {
            queryParameters = queryParameters.set('naturalDecayTime', <any>naturalDecayTime);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MiningExtraction>>(`${this.basePath}/ws/v1/corp/mining_extractions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get mining observations information
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param observerID Observer ID selector
     * @param characterID Character ID selector
     * @param typeID Type ID selector
     * @param recordedCorporationID Recorded corporation ID selector
     * @param quantity Quantity selector
     * @param lastUpdated Last updated time selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMiningObservations(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, observerID?: string, characterID?: string, typeID?: string, recordedCorporationID?: string, quantity?: string, lastUpdated?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MiningObservation>>;
    public getMiningObservations(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, observerID?: string, characterID?: string, typeID?: string, recordedCorporationID?: string, quantity?: string, lastUpdated?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MiningObservation>>>;
    public getMiningObservations(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, observerID?: string, characterID?: string, typeID?: string, recordedCorporationID?: string, quantity?: string, lastUpdated?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MiningObservation>>>;
    public getMiningObservations(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, observerID?: string, characterID?: string, typeID?: string, recordedCorporationID?: string, quantity?: string, lastUpdated?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getMiningObservations.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getMiningObservations.');
        }











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (observerID !== undefined && observerID !== null) {
            queryParameters = queryParameters.set('observerID', <any>observerID);
        }
        if (characterID !== undefined && characterID !== null) {
            queryParameters = queryParameters.set('characterID', <any>characterID);
        }
        if (typeID !== undefined && typeID !== null) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (recordedCorporationID !== undefined && recordedCorporationID !== null) {
            queryParameters = queryParameters.set('recordedCorporationID', <any>recordedCorporationID);
        }
        if (quantity !== undefined && quantity !== null) {
            queryParameters = queryParameters.set('quantity', <any>quantity);
        }
        if (lastUpdated !== undefined && lastUpdated !== null) {
            queryParameters = queryParameters.set('lastUpdated', <any>lastUpdated);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MiningObservation>>(`${this.basePath}/ws/v1/corp/mining_observations`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get mining observers information
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param observerID Observer ID selector
     * @param observerType Observer type selector
     * @param lastUpdated Last updated time selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMiningObservers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, observerID?: string, observerType?: string, lastUpdated?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MiningObserver>>;
    public getMiningObservers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, observerID?: string, observerType?: string, lastUpdated?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MiningObserver>>>;
    public getMiningObservers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, observerID?: string, observerType?: string, lastUpdated?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MiningObserver>>>;
    public getMiningObservers(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, observerID?: string, observerType?: string, lastUpdated?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getMiningObservers.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getMiningObservers.');
        }








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (observerID !== undefined && observerID !== null) {
            queryParameters = queryParameters.set('observerID', <any>observerID);
        }
        if (observerType !== undefined && observerType !== null) {
            queryParameters = queryParameters.set('observerType', <any>observerType);
        }
        if (lastUpdated !== undefined && lastUpdated !== null) {
            queryParameters = queryParameters.set('lastUpdated', <any>lastUpdated);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MiningObserver>>(`${this.basePath}/ws/v1/corp/mining_observers`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get corporation shareholders
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param shareholderID Shareholder ID selector
     * @param shareholderType Shareholder type selector
     * @param shares Shareholder shares selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getShareholders(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, shareholderID?: string, shareholderType?: string, shares?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Shareholder>>;
    public getShareholders(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, shareholderID?: string, shareholderType?: string, shares?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Shareholder>>>;
    public getShareholders(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, shareholderID?: string, shareholderType?: string, shares?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Shareholder>>>;
    public getShareholders(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, shareholderID?: string, shareholderType?: string, shares?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getShareholders.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getShareholders.');
        }








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (shareholderID !== undefined && shareholderID !== null) {
            queryParameters = queryParameters.set('shareholderID', <any>shareholderID);
        }
        if (shareholderType !== undefined && shareholderType !== null) {
            queryParameters = queryParameters.set('shareholderType', <any>shareholderType);
        }
        if (shares !== undefined && shares !== null) {
            queryParameters = queryParameters.set('shares', <any>shares);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Shareholder>>(`${this.basePath}/ws/v1/corp/shareholder`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get corporation starbases
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param starbaseID Starbase ID selector
     * @param typeID Starbase type ID selector
     * @param systemID Starbase system ID selector
     * @param moonID Starbase moon ID selector
     * @param state Starbase state selector
     * @param unanchorAt Starbase unanchor at timestamp selector
     * @param reinforcedUntil Starbase reinforced until timestamp selector
     * @param onlinedSince Starbase onlined since timestamp selector
     * @param fuelBayView Starbase fuel bay view selector
     * @param fuelBayTake Starbase fuel bay take selector
     * @param anchor Starbase anchor selector
     * @param unanchor Starbase unanchor selector
     * @param online Starbase online selector
     * @param offline Starbase offline selector
     * @param allowCorporationMembers Starbase allow corporation members selector
     * @param allowAllianceMembers Starbase allow alliance members selector
     * @param useAllianceStandings Starbase use alliance standings selector
     * @param attackStandingThreshold Starbase attack standing threshold selector
     * @param attackSecurityStatusThreshold Starbase attack security status threshold selector
     * @param attackIfOtherSecurityStatusDropping Starbase attack if other security status dropping selector
     * @param attackIfAtWar Starbase attack if at war selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStarbases(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, starbaseID?: string, typeID?: string, systemID?: string, moonID?: string, state?: string, unanchorAt?: string, reinforcedUntil?: string, onlinedSince?: string, fuelBayView?: string, fuelBayTake?: string, anchor?: string, unanchor?: string, online?: string, offline?: string, allowCorporationMembers?: string, allowAllianceMembers?: string, useAllianceStandings?: string, attackStandingThreshold?: string, attackSecurityStatusThreshold?: string, attackIfOtherSecurityStatusDropping?: string, attackIfAtWar?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Starbase>>;
    public getStarbases(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, starbaseID?: string, typeID?: string, systemID?: string, moonID?: string, state?: string, unanchorAt?: string, reinforcedUntil?: string, onlinedSince?: string, fuelBayView?: string, fuelBayTake?: string, anchor?: string, unanchor?: string, online?: string, offline?: string, allowCorporationMembers?: string, allowAllianceMembers?: string, useAllianceStandings?: string, attackStandingThreshold?: string, attackSecurityStatusThreshold?: string, attackIfOtherSecurityStatusDropping?: string, attackIfAtWar?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Starbase>>>;
    public getStarbases(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, starbaseID?: string, typeID?: string, systemID?: string, moonID?: string, state?: string, unanchorAt?: string, reinforcedUntil?: string, onlinedSince?: string, fuelBayView?: string, fuelBayTake?: string, anchor?: string, unanchor?: string, online?: string, offline?: string, allowCorporationMembers?: string, allowAllianceMembers?: string, useAllianceStandings?: string, attackStandingThreshold?: string, attackSecurityStatusThreshold?: string, attackIfOtherSecurityStatusDropping?: string, attackIfAtWar?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Starbase>>>;
    public getStarbases(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, starbaseID?: string, typeID?: string, systemID?: string, moonID?: string, state?: string, unanchorAt?: string, reinforcedUntil?: string, onlinedSince?: string, fuelBayView?: string, fuelBayTake?: string, anchor?: string, unanchor?: string, online?: string, offline?: string, allowCorporationMembers?: string, allowAllianceMembers?: string, useAllianceStandings?: string, attackStandingThreshold?: string, attackSecurityStatusThreshold?: string, attackIfOtherSecurityStatusDropping?: string, attackIfAtWar?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getStarbases.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getStarbases.');
        }


























        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (starbaseID !== undefined && starbaseID !== null) {
            queryParameters = queryParameters.set('starbaseID', <any>starbaseID);
        }
        if (typeID !== undefined && typeID !== null) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (systemID !== undefined && systemID !== null) {
            queryParameters = queryParameters.set('systemID', <any>systemID);
        }
        if (moonID !== undefined && moonID !== null) {
            queryParameters = queryParameters.set('moonID', <any>moonID);
        }
        if (state !== undefined && state !== null) {
            queryParameters = queryParameters.set('state', <any>state);
        }
        if (unanchorAt !== undefined && unanchorAt !== null) {
            queryParameters = queryParameters.set('unanchorAt', <any>unanchorAt);
        }
        if (reinforcedUntil !== undefined && reinforcedUntil !== null) {
            queryParameters = queryParameters.set('reinforcedUntil', <any>reinforcedUntil);
        }
        if (onlinedSince !== undefined && onlinedSince !== null) {
            queryParameters = queryParameters.set('onlinedSince', <any>onlinedSince);
        }
        if (fuelBayView !== undefined && fuelBayView !== null) {
            queryParameters = queryParameters.set('fuelBayView', <any>fuelBayView);
        }
        if (fuelBayTake !== undefined && fuelBayTake !== null) {
            queryParameters = queryParameters.set('fuelBayTake', <any>fuelBayTake);
        }
        if (anchor !== undefined && anchor !== null) {
            queryParameters = queryParameters.set('anchor', <any>anchor);
        }
        if (unanchor !== undefined && unanchor !== null) {
            queryParameters = queryParameters.set('unanchor', <any>unanchor);
        }
        if (online !== undefined && online !== null) {
            queryParameters = queryParameters.set('online', <any>online);
        }
        if (offline !== undefined && offline !== null) {
            queryParameters = queryParameters.set('offline', <any>offline);
        }
        if (allowCorporationMembers !== undefined && allowCorporationMembers !== null) {
            queryParameters = queryParameters.set('allowCorporationMembers', <any>allowCorporationMembers);
        }
        if (allowAllianceMembers !== undefined && allowAllianceMembers !== null) {
            queryParameters = queryParameters.set('allowAllianceMembers', <any>allowAllianceMembers);
        }
        if (useAllianceStandings !== undefined && useAllianceStandings !== null) {
            queryParameters = queryParameters.set('useAllianceStandings', <any>useAllianceStandings);
        }
        if (attackStandingThreshold !== undefined && attackStandingThreshold !== null) {
            queryParameters = queryParameters.set('attackStandingThreshold', <any>attackStandingThreshold);
        }
        if (attackSecurityStatusThreshold !== undefined && attackSecurityStatusThreshold !== null) {
            queryParameters = queryParameters.set('attackSecurityStatusThreshold', <any>attackSecurityStatusThreshold);
        }
        if (attackIfOtherSecurityStatusDropping !== undefined && attackIfOtherSecurityStatusDropping !== null) {
            queryParameters = queryParameters.set('attackIfOtherSecurityStatusDropping', <any>attackIfOtherSecurityStatusDropping);
        }
        if (attackIfAtWar !== undefined && attackIfAtWar !== null) {
            queryParameters = queryParameters.set('attackIfAtWar', <any>attackIfAtWar);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Starbase>>(`${this.basePath}/ws/v1/corp/starbase`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get structure services
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param structureID Structure ID selector
     * @param name Structure service name selector
     * @param state Structure service state selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStructureServices(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, structureID?: string, name?: string, state?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<StructureService>>;
    public getStructureServices(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, structureID?: string, name?: string, state?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<StructureService>>>;
    public getStructureServices(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, structureID?: string, name?: string, state?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<StructureService>>>;
    public getStructureServices(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, structureID?: string, name?: string, state?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getStructureServices.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getStructureServices.');
        }








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (structureID !== undefined && structureID !== null) {
            queryParameters = queryParameters.set('structureID', <any>structureID);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (state !== undefined && state !== null) {
            queryParameters = queryParameters.set('state', <any>state);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<StructureService>>(`${this.basePath}/ws/v1/corp/structure_services`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get structures
     * 
     * @param accessKey Model access key
     * @param accessCred Model access credential
     * @param at Model lifeline selector (defaults to current live data)
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reverse If true, page backwards (results less than contid) with results in descending order (by cid)
     * @param structureID Structure ID selector
     * @param corporationID Structure owning corporation ID selector
     * @param fuelExpires Structure fuel expires time selector
     * @param nextReinforceApply Structure next reinforce apply time selector
     * @param nextReinforceHour Structure next reinforce hour selector
     * @param nextReinforceWeekday Structure next reinforce weekday selector
     * @param profileID Structure profile ID selector
     * @param reinforceHour Structure reinforce hour selector
     * @param reinforceWeekday Structure reinforce weekday selector
     * @param state Structure state selector
     * @param stateTimerEnd Structure state timer end selector
     * @param stateTimerStart Structure state timer start selector
     * @param systemID Structure system ID selector
     * @param typeID Structure type ID selector
     * @param unanchorsAt Strcucture &#39;unanchors at&#39; time selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStructures(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, structureID?: string, corporationID?: string, fuelExpires?: string, nextReinforceApply?: string, nextReinforceHour?: string, nextReinforceWeekday?: string, profileID?: string, reinforceHour?: string, reinforceWeekday?: string, state?: string, stateTimerEnd?: string, stateTimerStart?: string, systemID?: string, typeID?: string, unanchorsAt?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Structure>>;
    public getStructures(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, structureID?: string, corporationID?: string, fuelExpires?: string, nextReinforceApply?: string, nextReinforceHour?: string, nextReinforceWeekday?: string, profileID?: string, reinforceHour?: string, reinforceWeekday?: string, state?: string, stateTimerEnd?: string, stateTimerStart?: string, systemID?: string, typeID?: string, unanchorsAt?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Structure>>>;
    public getStructures(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, structureID?: string, corporationID?: string, fuelExpires?: string, nextReinforceApply?: string, nextReinforceHour?: string, nextReinforceWeekday?: string, profileID?: string, reinforceHour?: string, reinforceWeekday?: string, state?: string, stateTimerEnd?: string, stateTimerStart?: string, systemID?: string, typeID?: string, unanchorsAt?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Structure>>>;
    public getStructures(accessKey: number, accessCred: string, at?: string, contid?: number, maxresults?: number, reverse?: boolean, structureID?: string, corporationID?: string, fuelExpires?: string, nextReinforceApply?: string, nextReinforceHour?: string, nextReinforceWeekday?: string, profileID?: string, reinforceHour?: string, reinforceWeekday?: string, state?: string, stateTimerEnd?: string, stateTimerStart?: string, systemID?: string, typeID?: string, unanchorsAt?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accessKey === null || accessKey === undefined) {
            throw new Error('Required parameter accessKey was null or undefined when calling getStructures.');
        }

        if (accessCred === null || accessCred === undefined) {
            throw new Error('Required parameter accessCred was null or undefined when calling getStructures.');
        }




















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (accessKey !== undefined && accessKey !== null) {
            queryParameters = queryParameters.set('accessKey', <any>accessKey);
        }
        if (accessCred !== undefined && accessCred !== null) {
            queryParameters = queryParameters.set('accessCred', <any>accessCred);
        }
        if (at !== undefined && at !== null) {
            queryParameters = queryParameters.set('at', <any>at);
        }
        if (contid !== undefined && contid !== null) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined && maxresults !== null) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reverse !== undefined && reverse !== null) {
            queryParameters = queryParameters.set('reverse', <any>reverse);
        }
        if (structureID !== undefined && structureID !== null) {
            queryParameters = queryParameters.set('structureID', <any>structureID);
        }
        if (corporationID !== undefined && corporationID !== null) {
            queryParameters = queryParameters.set('corporationID', <any>corporationID);
        }
        if (fuelExpires !== undefined && fuelExpires !== null) {
            queryParameters = queryParameters.set('fuelExpires', <any>fuelExpires);
        }
        if (nextReinforceApply !== undefined && nextReinforceApply !== null) {
            queryParameters = queryParameters.set('nextReinforceApply', <any>nextReinforceApply);
        }
        if (nextReinforceHour !== undefined && nextReinforceHour !== null) {
            queryParameters = queryParameters.set('nextReinforceHour', <any>nextReinforceHour);
        }
        if (nextReinforceWeekday !== undefined && nextReinforceWeekday !== null) {
            queryParameters = queryParameters.set('nextReinforceWeekday', <any>nextReinforceWeekday);
        }
        if (profileID !== undefined && profileID !== null) {
            queryParameters = queryParameters.set('profileID', <any>profileID);
        }
        if (reinforceHour !== undefined && reinforceHour !== null) {
            queryParameters = queryParameters.set('reinforceHour', <any>reinforceHour);
        }
        if (reinforceWeekday !== undefined && reinforceWeekday !== null) {
            queryParameters = queryParameters.set('reinforceWeekday', <any>reinforceWeekday);
        }
        if (state !== undefined && state !== null) {
            queryParameters = queryParameters.set('state', <any>state);
        }
        if (stateTimerEnd !== undefined && stateTimerEnd !== null) {
            queryParameters = queryParameters.set('stateTimerEnd', <any>stateTimerEnd);
        }
        if (stateTimerStart !== undefined && stateTimerStart !== null) {
            queryParameters = queryParameters.set('stateTimerStart', <any>stateTimerStart);
        }
        if (systemID !== undefined && systemID !== null) {
            queryParameters = queryParameters.set('systemID', <any>systemID);
        }
        if (typeID !== undefined && typeID !== null) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (unanchorsAt !== undefined && unanchorsAt !== null) {
            queryParameters = queryParameters.set('unanchorsAt', <any>unanchorsAt);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Structure>>(`${this.basePath}/ws/v1/corp/structures`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
