/**
 * EveKit SDE API Server
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2.0.0.20180713
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { MapCelestialStatistic } from '../model/mapCelestialStatistic';
import { MapConstellation } from '../model/mapConstellation';
import { MapConstellationJump } from '../model/mapConstellationJump';
import { MapDenormalize } from '../model/mapDenormalize';
import { MapJump } from '../model/mapJump';
import { MapLocationScene } from '../model/mapLocationScene';
import { MapLocationWormholeClass } from '../model/mapLocationWormholeClass';
import { MapRegion } from '../model/mapRegion';
import { MapRegionJump } from '../model/mapRegionJump';
import { MapSolarSystem } from '../model/mapSolarSystem';
import { MapSolarSystemJump } from '../model/mapSolarSystemJump';
import { MapUniverse } from '../model/mapUniverse';
import { ServiceError } from '../model/serviceError';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class MapService {

    protected basePath = 'https://evekit-sde.orbital.enterprises/20180713/api/ws/v20180713';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Get celestial statistics
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param celestialID Celestial ID selector
     * @param age Age selector
     * @param density Density selector
     * @param eccentricity Eccentricity selector
     * @param escapeVelocity Escape velocity selector
     * @param fragmented Fragmented flag selector
     * @param life Life flag selector
     * @param locked Locked flag selector
     * @param luminosity Luminosity selector
     * @param mass Mass selector
     * @param massDust Mass dust selector
     * @param massGas Mass gas selector
     * @param orbitPeriod Orbit period selector
     * @param orbitRadius Orbit radius selector
     * @param pressure Pressure selector
     * @param radius Radius selector
     * @param rotationRate Rotation rate selector
     * @param spectralClass Spectral class selector
     * @param surfaceGravity Surface gravity selector
     * @param temperature Temperature selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCelestialStatistics(contid?: number, maxresults?: number, celestialID?: string, age?: string, density?: string, eccentricity?: string, escapeVelocity?: string, fragmented?: string, life?: string, locked?: string, luminosity?: string, mass?: string, massDust?: string, massGas?: string, orbitPeriod?: string, orbitRadius?: string, pressure?: string, radius?: string, rotationRate?: string, spectralClass?: string, surfaceGravity?: string, temperature?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MapCelestialStatistic>>;
    public getCelestialStatistics(contid?: number, maxresults?: number, celestialID?: string, age?: string, density?: string, eccentricity?: string, escapeVelocity?: string, fragmented?: string, life?: string, locked?: string, luminosity?: string, mass?: string, massDust?: string, massGas?: string, orbitPeriod?: string, orbitRadius?: string, pressure?: string, radius?: string, rotationRate?: string, spectralClass?: string, surfaceGravity?: string, temperature?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MapCelestialStatistic>>>;
    public getCelestialStatistics(contid?: number, maxresults?: number, celestialID?: string, age?: string, density?: string, eccentricity?: string, escapeVelocity?: string, fragmented?: string, life?: string, locked?: string, luminosity?: string, mass?: string, massDust?: string, massGas?: string, orbitPeriod?: string, orbitRadius?: string, pressure?: string, radius?: string, rotationRate?: string, spectralClass?: string, surfaceGravity?: string, temperature?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MapCelestialStatistic>>>;
    public getCelestialStatistics(contid?: number, maxresults?: number, celestialID?: string, age?: string, density?: string, eccentricity?: string, escapeVelocity?: string, fragmented?: string, life?: string, locked?: string, luminosity?: string, mass?: string, massDust?: string, massGas?: string, orbitPeriod?: string, orbitRadius?: string, pressure?: string, radius?: string, rotationRate?: string, spectralClass?: string, surfaceGravity?: string, temperature?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (celestialID !== undefined) {
            queryParameters = queryParameters.set('celestialID', <any>celestialID);
        }
        if (age !== undefined) {
            queryParameters = queryParameters.set('age', <any>age);
        }
        if (density !== undefined) {
            queryParameters = queryParameters.set('density', <any>density);
        }
        if (eccentricity !== undefined) {
            queryParameters = queryParameters.set('eccentricity', <any>eccentricity);
        }
        if (escapeVelocity !== undefined) {
            queryParameters = queryParameters.set('escapeVelocity', <any>escapeVelocity);
        }
        if (fragmented !== undefined) {
            queryParameters = queryParameters.set('fragmented', <any>fragmented);
        }
        if (life !== undefined) {
            queryParameters = queryParameters.set('life', <any>life);
        }
        if (locked !== undefined) {
            queryParameters = queryParameters.set('locked', <any>locked);
        }
        if (luminosity !== undefined) {
            queryParameters = queryParameters.set('luminosity', <any>luminosity);
        }
        if (mass !== undefined) {
            queryParameters = queryParameters.set('mass', <any>mass);
        }
        if (massDust !== undefined) {
            queryParameters = queryParameters.set('massDust', <any>massDust);
        }
        if (massGas !== undefined) {
            queryParameters = queryParameters.set('massGas', <any>massGas);
        }
        if (orbitPeriod !== undefined) {
            queryParameters = queryParameters.set('orbitPeriod', <any>orbitPeriod);
        }
        if (orbitRadius !== undefined) {
            queryParameters = queryParameters.set('orbitRadius', <any>orbitRadius);
        }
        if (pressure !== undefined) {
            queryParameters = queryParameters.set('pressure', <any>pressure);
        }
        if (radius !== undefined) {
            queryParameters = queryParameters.set('radius', <any>radius);
        }
        if (rotationRate !== undefined) {
            queryParameters = queryParameters.set('rotationRate', <any>rotationRate);
        }
        if (spectralClass !== undefined) {
            queryParameters = queryParameters.set('spectralClass', <any>spectralClass);
        }
        if (surfaceGravity !== undefined) {
            queryParameters = queryParameters.set('surfaceGravity', <any>surfaceGravity);
        }
        if (temperature !== undefined) {
            queryParameters = queryParameters.set('temperature', <any>temperature);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MapCelestialStatistic>>(`${this.basePath}/map/celestial_statistic`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get constellation jumps
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param fromConstellationID From constellation ID selector
     * @param toConstellationID To constellation ID selector
     * @param fromRegionID From region ID selector
     * @param toRegionID To region ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getConstellationJumps(contid?: number, maxresults?: number, fromConstellationID?: string, toConstellationID?: string, fromRegionID?: string, toRegionID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MapConstellationJump>>;
    public getConstellationJumps(contid?: number, maxresults?: number, fromConstellationID?: string, toConstellationID?: string, fromRegionID?: string, toRegionID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MapConstellationJump>>>;
    public getConstellationJumps(contid?: number, maxresults?: number, fromConstellationID?: string, toConstellationID?: string, fromRegionID?: string, toRegionID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MapConstellationJump>>>;
    public getConstellationJumps(contid?: number, maxresults?: number, fromConstellationID?: string, toConstellationID?: string, fromRegionID?: string, toRegionID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (fromConstellationID !== undefined) {
            queryParameters = queryParameters.set('fromConstellationID', <any>fromConstellationID);
        }
        if (toConstellationID !== undefined) {
            queryParameters = queryParameters.set('toConstellationID', <any>toConstellationID);
        }
        if (fromRegionID !== undefined) {
            queryParameters = queryParameters.set('fromRegionID', <any>fromRegionID);
        }
        if (toRegionID !== undefined) {
            queryParameters = queryParameters.set('toRegionID', <any>toRegionID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MapConstellationJump>>(`${this.basePath}/map/constellation_jump`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get constellations
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param constellationID Constellation ID selector
     * @param constellationName Constellation name selector
     * @param factionID Faction ID selector
     * @param radius Radius selector
     * @param regionID Region ID selector
     * @param x X position selector
     * @param xMax Max X extent selector
     * @param xMin Min X extent selector
     * @param y Y position selector
     * @param yMax Max Y extent selector
     * @param yMin Min Y extent selector
     * @param z Z position selector
     * @param zMax Max Z extent selector
     * @param zMin Min Z extent selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getConstellations(contid?: number, maxresults?: number, constellationID?: string, constellationName?: string, factionID?: string, radius?: string, regionID?: string, x?: string, xMax?: string, xMin?: string, y?: string, yMax?: string, yMin?: string, z?: string, zMax?: string, zMin?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MapConstellation>>;
    public getConstellations(contid?: number, maxresults?: number, constellationID?: string, constellationName?: string, factionID?: string, radius?: string, regionID?: string, x?: string, xMax?: string, xMin?: string, y?: string, yMax?: string, yMin?: string, z?: string, zMax?: string, zMin?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MapConstellation>>>;
    public getConstellations(contid?: number, maxresults?: number, constellationID?: string, constellationName?: string, factionID?: string, radius?: string, regionID?: string, x?: string, xMax?: string, xMin?: string, y?: string, yMax?: string, yMin?: string, z?: string, zMax?: string, zMin?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MapConstellation>>>;
    public getConstellations(contid?: number, maxresults?: number, constellationID?: string, constellationName?: string, factionID?: string, radius?: string, regionID?: string, x?: string, xMax?: string, xMin?: string, y?: string, yMax?: string, yMin?: string, z?: string, zMax?: string, zMin?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (constellationID !== undefined) {
            queryParameters = queryParameters.set('constellationID', <any>constellationID);
        }
        if (constellationName !== undefined) {
            queryParameters = queryParameters.set('constellationName', <any>constellationName);
        }
        if (factionID !== undefined) {
            queryParameters = queryParameters.set('factionID', <any>factionID);
        }
        if (radius !== undefined) {
            queryParameters = queryParameters.set('radius', <any>radius);
        }
        if (regionID !== undefined) {
            queryParameters = queryParameters.set('regionID', <any>regionID);
        }
        if (x !== undefined) {
            queryParameters = queryParameters.set('x', <any>x);
        }
        if (xMax !== undefined) {
            queryParameters = queryParameters.set('xMax', <any>xMax);
        }
        if (xMin !== undefined) {
            queryParameters = queryParameters.set('xMin', <any>xMin);
        }
        if (y !== undefined) {
            queryParameters = queryParameters.set('y', <any>y);
        }
        if (yMax !== undefined) {
            queryParameters = queryParameters.set('yMax', <any>yMax);
        }
        if (yMin !== undefined) {
            queryParameters = queryParameters.set('yMin', <any>yMin);
        }
        if (z !== undefined) {
            queryParameters = queryParameters.set('z', <any>z);
        }
        if (zMax !== undefined) {
            queryParameters = queryParameters.set('zMax', <any>zMax);
        }
        if (zMin !== undefined) {
            queryParameters = queryParameters.set('zMin', <any>zMin);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MapConstellation>>(`${this.basePath}/map/constellation`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get denormalization
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param itemID Item ID selector
     * @param celestialIndex Celestial index selector
     * @param constellationID Constellation ID selector
     * @param groupID Group ID selector
     * @param itemName Item name selector
     * @param orbitID Orbit ID selector
     * @param orbitIndex Orbit index selector
     * @param radius Radius selector
     * @param regionID Region ID selector
     * @param security Security selector
     * @param solarSystemID Solar system ID selector
     * @param typeID Type ID selector
     * @param x X position selector
     * @param y Y position selector
     * @param z Z position selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDenormalization(contid?: number, maxresults?: number, itemID?: string, celestialIndex?: string, constellationID?: string, groupID?: string, itemName?: string, orbitID?: string, orbitIndex?: string, radius?: string, regionID?: string, security?: string, solarSystemID?: string, typeID?: string, x?: string, y?: string, z?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MapDenormalize>>;
    public getDenormalization(contid?: number, maxresults?: number, itemID?: string, celestialIndex?: string, constellationID?: string, groupID?: string, itemName?: string, orbitID?: string, orbitIndex?: string, radius?: string, regionID?: string, security?: string, solarSystemID?: string, typeID?: string, x?: string, y?: string, z?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MapDenormalize>>>;
    public getDenormalization(contid?: number, maxresults?: number, itemID?: string, celestialIndex?: string, constellationID?: string, groupID?: string, itemName?: string, orbitID?: string, orbitIndex?: string, radius?: string, regionID?: string, security?: string, solarSystemID?: string, typeID?: string, x?: string, y?: string, z?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MapDenormalize>>>;
    public getDenormalization(contid?: number, maxresults?: number, itemID?: string, celestialIndex?: string, constellationID?: string, groupID?: string, itemName?: string, orbitID?: string, orbitIndex?: string, radius?: string, regionID?: string, security?: string, solarSystemID?: string, typeID?: string, x?: string, y?: string, z?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (itemID !== undefined) {
            queryParameters = queryParameters.set('itemID', <any>itemID);
        }
        if (celestialIndex !== undefined) {
            queryParameters = queryParameters.set('celestialIndex', <any>celestialIndex);
        }
        if (constellationID !== undefined) {
            queryParameters = queryParameters.set('constellationID', <any>constellationID);
        }
        if (groupID !== undefined) {
            queryParameters = queryParameters.set('groupID', <any>groupID);
        }
        if (itemName !== undefined) {
            queryParameters = queryParameters.set('itemName', <any>itemName);
        }
        if (orbitID !== undefined) {
            queryParameters = queryParameters.set('orbitID', <any>orbitID);
        }
        if (orbitIndex !== undefined) {
            queryParameters = queryParameters.set('orbitIndex', <any>orbitIndex);
        }
        if (radius !== undefined) {
            queryParameters = queryParameters.set('radius', <any>radius);
        }
        if (regionID !== undefined) {
            queryParameters = queryParameters.set('regionID', <any>regionID);
        }
        if (security !== undefined) {
            queryParameters = queryParameters.set('security', <any>security);
        }
        if (solarSystemID !== undefined) {
            queryParameters = queryParameters.set('solarSystemID', <any>solarSystemID);
        }
        if (typeID !== undefined) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (x !== undefined) {
            queryParameters = queryParameters.set('x', <any>x);
        }
        if (y !== undefined) {
            queryParameters = queryParameters.set('y', <any>y);
        }
        if (z !== undefined) {
            queryParameters = queryParameters.set('z', <any>z);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MapDenormalize>>(`${this.basePath}/map/denormalize`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get jumps
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param stargateID Stargate ID selector
     * @param destinationID Destination ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getJumps(contid?: number, maxresults?: number, stargateID?: string, destinationID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MapJump>>;
    public getJumps(contid?: number, maxresults?: number, stargateID?: string, destinationID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MapJump>>>;
    public getJumps(contid?: number, maxresults?: number, stargateID?: string, destinationID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MapJump>>>;
    public getJumps(contid?: number, maxresults?: number, stargateID?: string, destinationID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (stargateID !== undefined) {
            queryParameters = queryParameters.set('stargateID', <any>stargateID);
        }
        if (destinationID !== undefined) {
            queryParameters = queryParameters.set('destinationID', <any>destinationID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MapJump>>(`${this.basePath}/map/jump`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get location scenes
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param locationID Location ID selector
     * @param graphicID Graphic ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLocationScenes(contid?: number, maxresults?: number, locationID?: string, graphicID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MapLocationScene>>;
    public getLocationScenes(contid?: number, maxresults?: number, locationID?: string, graphicID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MapLocationScene>>>;
    public getLocationScenes(contid?: number, maxresults?: number, locationID?: string, graphicID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MapLocationScene>>>;
    public getLocationScenes(contid?: number, maxresults?: number, locationID?: string, graphicID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (locationID !== undefined) {
            queryParameters = queryParameters.set('locationID', <any>locationID);
        }
        if (graphicID !== undefined) {
            queryParameters = queryParameters.set('graphicID', <any>graphicID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MapLocationScene>>(`${this.basePath}/map/location_scene`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get location wormhole classes
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param locationID Location ID selector
     * @param wormholeClassID Wormhole class ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLocationWormholeClasses(contid?: number, maxresults?: number, locationID?: string, wormholeClassID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MapLocationWormholeClass>>;
    public getLocationWormholeClasses(contid?: number, maxresults?: number, locationID?: string, wormholeClassID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MapLocationWormholeClass>>>;
    public getLocationWormholeClasses(contid?: number, maxresults?: number, locationID?: string, wormholeClassID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MapLocationWormholeClass>>>;
    public getLocationWormholeClasses(contid?: number, maxresults?: number, locationID?: string, wormholeClassID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (locationID !== undefined) {
            queryParameters = queryParameters.set('locationID', <any>locationID);
        }
        if (wormholeClassID !== undefined) {
            queryParameters = queryParameters.set('wormholeClassID', <any>wormholeClassID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MapLocationWormholeClass>>(`${this.basePath}/map/location_wormhole_class`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get region jumps
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param fromRegionID From region ID selector
     * @param toRegionID To region ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRegionJumps(contid?: number, maxresults?: number, fromRegionID?: string, toRegionID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MapRegionJump>>;
    public getRegionJumps(contid?: number, maxresults?: number, fromRegionID?: string, toRegionID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MapRegionJump>>>;
    public getRegionJumps(contid?: number, maxresults?: number, fromRegionID?: string, toRegionID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MapRegionJump>>>;
    public getRegionJumps(contid?: number, maxresults?: number, fromRegionID?: string, toRegionID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (fromRegionID !== undefined) {
            queryParameters = queryParameters.set('fromRegionID', <any>fromRegionID);
        }
        if (toRegionID !== undefined) {
            queryParameters = queryParameters.set('toRegionID', <any>toRegionID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MapRegionJump>>(`${this.basePath}/map/region_jump`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get regions
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param regionID Region ID selector
     * @param factionID Faction ID selector
     * @param radius Radius selector
     * @param regionName Region name selector
     * @param x X position selector
     * @param xMax Max X extent selector
     * @param xMin Min X extent selector
     * @param y Y position selector
     * @param yMax Max Y extent selector
     * @param yMin Min Y extent selector
     * @param z Z position selector
     * @param zMax Max Z extent selector
     * @param zMin Min Z extent selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRegions(contid?: number, maxresults?: number, regionID?: string, factionID?: string, radius?: string, regionName?: string, x?: string, xMax?: string, xMin?: string, y?: string, yMax?: string, yMin?: string, z?: string, zMax?: string, zMin?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MapRegion>>;
    public getRegions(contid?: number, maxresults?: number, regionID?: string, factionID?: string, radius?: string, regionName?: string, x?: string, xMax?: string, xMin?: string, y?: string, yMax?: string, yMin?: string, z?: string, zMax?: string, zMin?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MapRegion>>>;
    public getRegions(contid?: number, maxresults?: number, regionID?: string, factionID?: string, radius?: string, regionName?: string, x?: string, xMax?: string, xMin?: string, y?: string, yMax?: string, yMin?: string, z?: string, zMax?: string, zMin?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MapRegion>>>;
    public getRegions(contid?: number, maxresults?: number, regionID?: string, factionID?: string, radius?: string, regionName?: string, x?: string, xMax?: string, xMin?: string, y?: string, yMax?: string, yMin?: string, z?: string, zMax?: string, zMin?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (regionID !== undefined) {
            queryParameters = queryParameters.set('regionID', <any>regionID);
        }
        if (factionID !== undefined) {
            queryParameters = queryParameters.set('factionID', <any>factionID);
        }
        if (radius !== undefined) {
            queryParameters = queryParameters.set('radius', <any>radius);
        }
        if (regionName !== undefined) {
            queryParameters = queryParameters.set('regionName', <any>regionName);
        }
        if (x !== undefined) {
            queryParameters = queryParameters.set('x', <any>x);
        }
        if (xMax !== undefined) {
            queryParameters = queryParameters.set('xMax', <any>xMax);
        }
        if (xMin !== undefined) {
            queryParameters = queryParameters.set('xMin', <any>xMin);
        }
        if (y !== undefined) {
            queryParameters = queryParameters.set('y', <any>y);
        }
        if (yMax !== undefined) {
            queryParameters = queryParameters.set('yMax', <any>yMax);
        }
        if (yMin !== undefined) {
            queryParameters = queryParameters.set('yMin', <any>yMin);
        }
        if (z !== undefined) {
            queryParameters = queryParameters.set('z', <any>z);
        }
        if (zMax !== undefined) {
            queryParameters = queryParameters.set('zMax', <any>zMax);
        }
        if (zMin !== undefined) {
            queryParameters = queryParameters.set('zMin', <any>zMin);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MapRegion>>(`${this.basePath}/map/region`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get solar system jumps
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param fromSolarSystemID Source solar system ID selector
     * @param toSolarSystemID Destination solar system ID selector
     * @param fromConstellationID Source constellation ID selector
     * @param fromRegionID Source region ID selector
     * @param toConstellationID Destination constellation ID selector
     * @param toRegionID Destination region ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSolarSystemJumps(contid?: number, maxresults?: number, fromSolarSystemID?: string, toSolarSystemID?: string, fromConstellationID?: string, fromRegionID?: string, toConstellationID?: string, toRegionID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MapSolarSystemJump>>;
    public getSolarSystemJumps(contid?: number, maxresults?: number, fromSolarSystemID?: string, toSolarSystemID?: string, fromConstellationID?: string, fromRegionID?: string, toConstellationID?: string, toRegionID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MapSolarSystemJump>>>;
    public getSolarSystemJumps(contid?: number, maxresults?: number, fromSolarSystemID?: string, toSolarSystemID?: string, fromConstellationID?: string, fromRegionID?: string, toConstellationID?: string, toRegionID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MapSolarSystemJump>>>;
    public getSolarSystemJumps(contid?: number, maxresults?: number, fromSolarSystemID?: string, toSolarSystemID?: string, fromConstellationID?: string, fromRegionID?: string, toConstellationID?: string, toRegionID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (fromSolarSystemID !== undefined) {
            queryParameters = queryParameters.set('fromSolarSystemID', <any>fromSolarSystemID);
        }
        if (toSolarSystemID !== undefined) {
            queryParameters = queryParameters.set('toSolarSystemID', <any>toSolarSystemID);
        }
        if (fromConstellationID !== undefined) {
            queryParameters = queryParameters.set('fromConstellationID', <any>fromConstellationID);
        }
        if (fromRegionID !== undefined) {
            queryParameters = queryParameters.set('fromRegionID', <any>fromRegionID);
        }
        if (toConstellationID !== undefined) {
            queryParameters = queryParameters.set('toConstellationID', <any>toConstellationID);
        }
        if (toRegionID !== undefined) {
            queryParameters = queryParameters.set('toRegionID', <any>toRegionID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MapSolarSystemJump>>(`${this.basePath}/map/solar_system_jump`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get solar systems
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param solarSystemID Solar system ID selector
     * @param border Border flag selector
     * @param constellation Constellation selector
     * @param constellationID Constellation ID selector
     * @param corridor Corridor flag selector
     * @param factionID Faction ID selector
     * @param fringe Fringe flag selector
     * @param hub Hub flag selector
     * @param international International flag selector
     * @param luminosity Luminosity selector
     * @param radius Radius selector
     * @param regional Regional flag selector
     * @param regionID Region ID selector
     * @param security Security selector
     * @param securityClass Security class selector
     * @param solarSystemName Solar system name selector
     * @param sunTypeID Sun type ID selector
     * @param x X position selector
     * @param xMax Max X extent selector
     * @param xMin Min X extent selector
     * @param y Y position selector
     * @param yMax Max Y extent selector
     * @param yMin Min Y extent selector
     * @param z Z position selector
     * @param zMax Max Z extent selector
     * @param zMin Min Z extent selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSolarSystems(contid?: number, maxresults?: number, solarSystemID?: string, border?: string, constellation?: string, constellationID?: string, corridor?: string, factionID?: string, fringe?: string, hub?: string, international?: string, luminosity?: string, radius?: string, regional?: string, regionID?: string, security?: string, securityClass?: string, solarSystemName?: string, sunTypeID?: string, x?: string, xMax?: string, xMin?: string, y?: string, yMax?: string, yMin?: string, z?: string, zMax?: string, zMin?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MapSolarSystem>>;
    public getSolarSystems(contid?: number, maxresults?: number, solarSystemID?: string, border?: string, constellation?: string, constellationID?: string, corridor?: string, factionID?: string, fringe?: string, hub?: string, international?: string, luminosity?: string, radius?: string, regional?: string, regionID?: string, security?: string, securityClass?: string, solarSystemName?: string, sunTypeID?: string, x?: string, xMax?: string, xMin?: string, y?: string, yMax?: string, yMin?: string, z?: string, zMax?: string, zMin?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MapSolarSystem>>>;
    public getSolarSystems(contid?: number, maxresults?: number, solarSystemID?: string, border?: string, constellation?: string, constellationID?: string, corridor?: string, factionID?: string, fringe?: string, hub?: string, international?: string, luminosity?: string, radius?: string, regional?: string, regionID?: string, security?: string, securityClass?: string, solarSystemName?: string, sunTypeID?: string, x?: string, xMax?: string, xMin?: string, y?: string, yMax?: string, yMin?: string, z?: string, zMax?: string, zMin?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MapSolarSystem>>>;
    public getSolarSystems(contid?: number, maxresults?: number, solarSystemID?: string, border?: string, constellation?: string, constellationID?: string, corridor?: string, factionID?: string, fringe?: string, hub?: string, international?: string, luminosity?: string, radius?: string, regional?: string, regionID?: string, security?: string, securityClass?: string, solarSystemName?: string, sunTypeID?: string, x?: string, xMax?: string, xMin?: string, y?: string, yMax?: string, yMin?: string, z?: string, zMax?: string, zMin?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (solarSystemID !== undefined) {
            queryParameters = queryParameters.set('solarSystemID', <any>solarSystemID);
        }
        if (border !== undefined) {
            queryParameters = queryParameters.set('border', <any>border);
        }
        if (constellation !== undefined) {
            queryParameters = queryParameters.set('constellation', <any>constellation);
        }
        if (constellationID !== undefined) {
            queryParameters = queryParameters.set('constellationID', <any>constellationID);
        }
        if (corridor !== undefined) {
            queryParameters = queryParameters.set('corridor', <any>corridor);
        }
        if (factionID !== undefined) {
            queryParameters = queryParameters.set('factionID', <any>factionID);
        }
        if (fringe !== undefined) {
            queryParameters = queryParameters.set('fringe', <any>fringe);
        }
        if (hub !== undefined) {
            queryParameters = queryParameters.set('hub', <any>hub);
        }
        if (international !== undefined) {
            queryParameters = queryParameters.set('international', <any>international);
        }
        if (luminosity !== undefined) {
            queryParameters = queryParameters.set('luminosity', <any>luminosity);
        }
        if (radius !== undefined) {
            queryParameters = queryParameters.set('radius', <any>radius);
        }
        if (regional !== undefined) {
            queryParameters = queryParameters.set('regional', <any>regional);
        }
        if (regionID !== undefined) {
            queryParameters = queryParameters.set('regionID', <any>regionID);
        }
        if (security !== undefined) {
            queryParameters = queryParameters.set('security', <any>security);
        }
        if (securityClass !== undefined) {
            queryParameters = queryParameters.set('securityClass', <any>securityClass);
        }
        if (solarSystemName !== undefined) {
            queryParameters = queryParameters.set('solarSystemName', <any>solarSystemName);
        }
        if (sunTypeID !== undefined) {
            queryParameters = queryParameters.set('sunTypeID', <any>sunTypeID);
        }
        if (x !== undefined) {
            queryParameters = queryParameters.set('x', <any>x);
        }
        if (xMax !== undefined) {
            queryParameters = queryParameters.set('xMax', <any>xMax);
        }
        if (xMin !== undefined) {
            queryParameters = queryParameters.set('xMin', <any>xMin);
        }
        if (y !== undefined) {
            queryParameters = queryParameters.set('y', <any>y);
        }
        if (yMax !== undefined) {
            queryParameters = queryParameters.set('yMax', <any>yMax);
        }
        if (yMin !== undefined) {
            queryParameters = queryParameters.set('yMin', <any>yMin);
        }
        if (z !== undefined) {
            queryParameters = queryParameters.set('z', <any>z);
        }
        if (zMax !== undefined) {
            queryParameters = queryParameters.set('zMax', <any>zMax);
        }
        if (zMin !== undefined) {
            queryParameters = queryParameters.set('zMin', <any>zMin);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MapSolarSystem>>(`${this.basePath}/map/solar_system`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get universes
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param universeID Universe ID selector
     * @param radius Radius selector
     * @param universeName Universe name selector
     * @param x X position selector
     * @param xMax Max X extent selector
     * @param xMin Min X extent selector
     * @param y Y position selector
     * @param yMax Max Y extent selector
     * @param yMin Min Y extent selector
     * @param z Z position selector
     * @param zMax Max Z extent selector
     * @param zMin Min Z extent selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverses(contid?: number, maxresults?: number, universeID?: string, radius?: string, universeName?: string, x?: string, xMax?: string, xMin?: string, y?: string, yMax?: string, yMin?: string, z?: string, zMax?: string, zMin?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MapUniverse>>;
    public getUniverses(contid?: number, maxresults?: number, universeID?: string, radius?: string, universeName?: string, x?: string, xMax?: string, xMin?: string, y?: string, yMax?: string, yMin?: string, z?: string, zMax?: string, zMin?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MapUniverse>>>;
    public getUniverses(contid?: number, maxresults?: number, universeID?: string, radius?: string, universeName?: string, x?: string, xMax?: string, xMin?: string, y?: string, yMax?: string, yMin?: string, z?: string, zMax?: string, zMin?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MapUniverse>>>;
    public getUniverses(contid?: number, maxresults?: number, universeID?: string, radius?: string, universeName?: string, x?: string, xMax?: string, xMin?: string, y?: string, yMax?: string, yMin?: string, z?: string, zMax?: string, zMin?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (universeID !== undefined) {
            queryParameters = queryParameters.set('universeID', <any>universeID);
        }
        if (radius !== undefined) {
            queryParameters = queryParameters.set('radius', <any>radius);
        }
        if (universeName !== undefined) {
            queryParameters = queryParameters.set('universeName', <any>universeName);
        }
        if (x !== undefined) {
            queryParameters = queryParameters.set('x', <any>x);
        }
        if (xMax !== undefined) {
            queryParameters = queryParameters.set('xMax', <any>xMax);
        }
        if (xMin !== undefined) {
            queryParameters = queryParameters.set('xMin', <any>xMin);
        }
        if (y !== undefined) {
            queryParameters = queryParameters.set('y', <any>y);
        }
        if (yMax !== undefined) {
            queryParameters = queryParameters.set('yMax', <any>yMax);
        }
        if (yMin !== undefined) {
            queryParameters = queryParameters.set('yMin', <any>yMin);
        }
        if (z !== undefined) {
            queryParameters = queryParameters.set('z', <any>z);
        }
        if (zMax !== undefined) {
            queryParameters = queryParameters.set('zMax', <any>zMax);
        }
        if (zMin !== undefined) {
            queryParameters = queryParameters.set('zMin', <any>zMin);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MapUniverse>>(`${this.basePath}/map/universe`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
