/**
 * EveKit SDE API Server
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2.0.0.20180529
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import {Inject, Injectable, Optional} from '@angular/core';
import {HttpClient, HttpEvent, HttpHeaders, HttpParams, HttpResponse} from '@angular/common/http';
import {CustomHttpUrlEncodingCodec} from '../encoder';

import {Observable} from 'rxjs';

import {RamActivity} from '../model/ramActivity';
import {RamAssemblyLineStation} from '../model/ramAssemblyLineStation';
import {RamAssemblyLineType} from '../model/ramAssemblyLineType';
import {RamAssemblyLineTypeDetailPerCategory} from '../model/ramAssemblyLineTypeDetailPerCategory';
import {RamAssemblyLineTypeDetailPerGroup} from '../model/ramAssemblyLineTypeDetailPerGroup';
import {RamInstallationTypeContent} from '../model/ramInstallationTypeContent';

import {SDE_BASE_PATH} from '../variables';
import {Configuration} from '../configuration';


@Injectable()
export class RAMService {

    protected basePath = 'http://localhost:8080/evekit-sde/api/ws/v20180529';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(SDE_BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Get assembly line stations
     *
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param stationID Station ID selector
     * @param assemblyLineTypeID Assembly line type ID selector
     * @param ownerID Owner ID selector
     * @param quantity Quantity selector
     * @param regionID Region ID selector
     * @param solarSystemID Solary system ID selector
     * @param stationTypeID Station type ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAssemblyLineStations(contid?: number, maxresults?: number, stationID?: string, assemblyLineTypeID?: string, ownerID?: string, quantity?: string, regionID?: string, solarSystemID?: string, stationTypeID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<RamAssemblyLineStation>>;
    public getAssemblyLineStations(contid?: number, maxresults?: number, stationID?: string, assemblyLineTypeID?: string, ownerID?: string, quantity?: string, regionID?: string, solarSystemID?: string, stationTypeID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RamAssemblyLineStation>>>;
    public getAssemblyLineStations(contid?: number, maxresults?: number, stationID?: string, assemblyLineTypeID?: string, ownerID?: string, quantity?: string, regionID?: string, solarSystemID?: string, stationTypeID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RamAssemblyLineStation>>>;
    public getAssemblyLineStations(contid?: number, maxresults?: number, stationID?: string, assemblyLineTypeID?: string, ownerID?: string, quantity?: string, regionID?: string, solarSystemID?: string, stationTypeID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (stationID !== undefined) {
            queryParameters = queryParameters.set('stationID', <any>stationID);
        }
        if (assemblyLineTypeID !== undefined) {
            queryParameters = queryParameters.set('assemblyLineTypeID', <any>assemblyLineTypeID);
        }
        if (ownerID !== undefined) {
            queryParameters = queryParameters.set('ownerID', <any>ownerID);
        }
        if (quantity !== undefined) {
            queryParameters = queryParameters.set('quantity', <any>quantity);
        }
        if (regionID !== undefined) {
            queryParameters = queryParameters.set('regionID', <any>regionID);
        }
        if (solarSystemID !== undefined) {
            queryParameters = queryParameters.set('solarSystemID', <any>solarSystemID);
        }
        if (stationTypeID !== undefined) {
            queryParameters = queryParameters.set('stationTypeID', <any>stationTypeID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<RamAssemblyLineStation>>(`${this.basePath}/ram/assembly_line_station`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get assembly line type details per category
     *
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param assemblyLineTypeID Assembly line type ID selector
     * @param categoryID Category ID selector
     * @param costMultiplier Cost multiplier selector
     * @param materialMultiplier Material multiplier selector
     * @param timeMultiplier Time multiplier selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAssemblyLineTypeDetailsPerCategory(contid?: number, maxresults?: number, assemblyLineTypeID?: string, categoryID?: string, costMultiplier?: string, materialMultiplier?: string, timeMultiplier?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<RamAssemblyLineTypeDetailPerCategory>>;
    public getAssemblyLineTypeDetailsPerCategory(contid?: number, maxresults?: number, assemblyLineTypeID?: string, categoryID?: string, costMultiplier?: string, materialMultiplier?: string, timeMultiplier?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RamAssemblyLineTypeDetailPerCategory>>>;
    public getAssemblyLineTypeDetailsPerCategory(contid?: number, maxresults?: number, assemblyLineTypeID?: string, categoryID?: string, costMultiplier?: string, materialMultiplier?: string, timeMultiplier?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RamAssemblyLineTypeDetailPerCategory>>>;
    public getAssemblyLineTypeDetailsPerCategory(contid?: number, maxresults?: number, assemblyLineTypeID?: string, categoryID?: string, costMultiplier?: string, materialMultiplier?: string, timeMultiplier?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (assemblyLineTypeID !== undefined) {
            queryParameters = queryParameters.set('assemblyLineTypeID', <any>assemblyLineTypeID);
        }
        if (categoryID !== undefined) {
            queryParameters = queryParameters.set('categoryID', <any>categoryID);
        }
        if (costMultiplier !== undefined) {
            queryParameters = queryParameters.set('costMultiplier', <any>costMultiplier);
        }
        if (materialMultiplier !== undefined) {
            queryParameters = queryParameters.set('materialMultiplier', <any>materialMultiplier);
        }
        if (timeMultiplier !== undefined) {
            queryParameters = queryParameters.set('timeMultiplier', <any>timeMultiplier);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<RamAssemblyLineTypeDetailPerCategory>>(`${this.basePath}/ram/assembly_line_type_detail_per_category`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get assembly line type details per group
     *
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param assemblyLineTypeID Assembly line type ID selector
     * @param groupID Group ID selector
     * @param costMultiplier Cost multiplier selector
     * @param materialMultiplier Material multiplier selector
     * @param timeMultiplier Time multiplier selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAssemblyLineTypeDetailsPerGroup(contid?: number, maxresults?: number, assemblyLineTypeID?: string, groupID?: string, costMultiplier?: string, materialMultiplier?: string, timeMultiplier?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<RamAssemblyLineTypeDetailPerGroup>>;
    public getAssemblyLineTypeDetailsPerGroup(contid?: number, maxresults?: number, assemblyLineTypeID?: string, groupID?: string, costMultiplier?: string, materialMultiplier?: string, timeMultiplier?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RamAssemblyLineTypeDetailPerGroup>>>;
    public getAssemblyLineTypeDetailsPerGroup(contid?: number, maxresults?: number, assemblyLineTypeID?: string, groupID?: string, costMultiplier?: string, materialMultiplier?: string, timeMultiplier?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RamAssemblyLineTypeDetailPerGroup>>>;
    public getAssemblyLineTypeDetailsPerGroup(contid?: number, maxresults?: number, assemblyLineTypeID?: string, groupID?: string, costMultiplier?: string, materialMultiplier?: string, timeMultiplier?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (assemblyLineTypeID !== undefined) {
            queryParameters = queryParameters.set('assemblyLineTypeID', <any>assemblyLineTypeID);
        }
        if (groupID !== undefined) {
            queryParameters = queryParameters.set('groupID', <any>groupID);
        }
        if (costMultiplier !== undefined) {
            queryParameters = queryParameters.set('costMultiplier', <any>costMultiplier);
        }
        if (materialMultiplier !== undefined) {
            queryParameters = queryParameters.set('materialMultiplier', <any>materialMultiplier);
        }
        if (timeMultiplier !== undefined) {
            queryParameters = queryParameters.set('timeMultiplier', <any>timeMultiplier);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<RamAssemblyLineTypeDetailPerGroup>>(`${this.basePath}/ram/assembly_line_type_detail_per_group`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get assembly line types
     *
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param assemblyLineTypeID Assembly line type ID selector
     * @param activityID Activity ID selector
     * @param assemblyLineTypeName Assembly line type name selector
     * @param baseCostMultiplier Base cost multiplier selector
     * @param baseMaterialMultiplier Base material multiplier selector
     * @param baseTimeMultiplier Base time multiplier selector
     * @param description Description text selector
     * @param minCostPerHour Minimum cost per hour selector
     * @param volume Volume selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAssemblyLineTypes(contid?: number, maxresults?: number, assemblyLineTypeID?: string, activityID?: string, assemblyLineTypeName?: string, baseCostMultiplier?: string, baseMaterialMultiplier?: string, baseTimeMultiplier?: string, description?: string, minCostPerHour?: string, volume?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<RamAssemblyLineType>>;
    public getAssemblyLineTypes(contid?: number, maxresults?: number, assemblyLineTypeID?: string, activityID?: string, assemblyLineTypeName?: string, baseCostMultiplier?: string, baseMaterialMultiplier?: string, baseTimeMultiplier?: string, description?: string, minCostPerHour?: string, volume?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RamAssemblyLineType>>>;
    public getAssemblyLineTypes(contid?: number, maxresults?: number, assemblyLineTypeID?: string, activityID?: string, assemblyLineTypeName?: string, baseCostMultiplier?: string, baseMaterialMultiplier?: string, baseTimeMultiplier?: string, description?: string, minCostPerHour?: string, volume?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RamAssemblyLineType>>>;
    public getAssemblyLineTypes(contid?: number, maxresults?: number, assemblyLineTypeID?: string, activityID?: string, assemblyLineTypeName?: string, baseCostMultiplier?: string, baseMaterialMultiplier?: string, baseTimeMultiplier?: string, description?: string, minCostPerHour?: string, volume?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (assemblyLineTypeID !== undefined) {
            queryParameters = queryParameters.set('assemblyLineTypeID', <any>assemblyLineTypeID);
        }
        if (activityID !== undefined) {
            queryParameters = queryParameters.set('activityID', <any>activityID);
        }
        if (assemblyLineTypeName !== undefined) {
            queryParameters = queryParameters.set('assemblyLineTypeName', <any>assemblyLineTypeName);
        }
        if (baseCostMultiplier !== undefined) {
            queryParameters = queryParameters.set('baseCostMultiplier', <any>baseCostMultiplier);
        }
        if (baseMaterialMultiplier !== undefined) {
            queryParameters = queryParameters.set('baseMaterialMultiplier', <any>baseMaterialMultiplier);
        }
        if (baseTimeMultiplier !== undefined) {
            queryParameters = queryParameters.set('baseTimeMultiplier', <any>baseTimeMultiplier);
        }
        if (description !== undefined) {
            queryParameters = queryParameters.set('description', <any>description);
        }
        if (minCostPerHour !== undefined) {
            queryParameters = queryParameters.set('minCostPerHour', <any>minCostPerHour);
        }
        if (volume !== undefined) {
            queryParameters = queryParameters.set('volume', <any>volume);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<RamAssemblyLineType>>(`${this.basePath}/ram/assembly_line_type`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get installation type contents
     *
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param installationTypeID Installation type ID selector
     * @param assemblyLineTypeID Assembly line type ID selector
     * @param quantity Quantity selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getInstallationTypeContents(contid?: number, maxresults?: number, installationTypeID?: string, assemblyLineTypeID?: string, quantity?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<RamInstallationTypeContent>>;
    public getInstallationTypeContents(contid?: number, maxresults?: number, installationTypeID?: string, assemblyLineTypeID?: string, quantity?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RamInstallationTypeContent>>>;
    public getInstallationTypeContents(contid?: number, maxresults?: number, installationTypeID?: string, assemblyLineTypeID?: string, quantity?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RamInstallationTypeContent>>>;
    public getInstallationTypeContents(contid?: number, maxresults?: number, installationTypeID?: string, assemblyLineTypeID?: string, quantity?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (installationTypeID !== undefined) {
            queryParameters = queryParameters.set('installationTypeID', <any>installationTypeID);
        }
        if (assemblyLineTypeID !== undefined) {
            queryParameters = queryParameters.set('assemblyLineTypeID', <any>assemblyLineTypeID);
        }
        if (quantity !== undefined) {
            queryParameters = queryParameters.set('quantity', <any>quantity);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<RamInstallationTypeContent>>(`${this.basePath}/ram/installation_type_content`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get activities
     *
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param activityID Activity ID selector
     * @param activityName Activity name selector
     * @param description Description text selector
     * @param iconNo Icon number selector
     * @param published Published flag selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRAMActivities(contid?: number, maxresults?: number, activityID?: string, activityName?: string, description?: string, iconNo?: string, published?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<RamActivity>>;
    public getRAMActivities(contid?: number, maxresults?: number, activityID?: string, activityName?: string, description?: string, iconNo?: string, published?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RamActivity>>>;
    public getRAMActivities(contid?: number, maxresults?: number, activityID?: string, activityName?: string, description?: string, iconNo?: string, published?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RamActivity>>>;
    public getRAMActivities(contid?: number, maxresults?: number, activityID?: string, activityName?: string, description?: string, iconNo?: string, published?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (activityID !== undefined) {
            queryParameters = queryParameters.set('activityID', <any>activityID);
        }
        if (activityName !== undefined) {
            queryParameters = queryParameters.set('activityName', <any>activityName);
        }
        if (description !== undefined) {
            queryParameters = queryParameters.set('description', <any>description);
        }
        if (iconNo !== undefined) {
            queryParameters = queryParameters.set('iconNo', <any>iconNo);
        }
        if (published !== undefined) {
            queryParameters = queryParameters.set('published', <any>published);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<RamActivity>>(`${this.basePath}/ram/activity`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
