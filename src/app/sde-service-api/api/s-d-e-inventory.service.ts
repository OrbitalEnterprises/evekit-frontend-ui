/**
 * EveKit SDE API Server
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2.0.0.20180713
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { InvCategory } from '../model/invCategory';
import { InvContrabandType } from '../model/invContrabandType';
import { InvControlTowerResource } from '../model/invControlTowerResource';
import { InvControlTowerResourcePurpose } from '../model/invControlTowerResourcePurpose';
import { InvFlag } from '../model/invFlag';
import { InvGroup } from '../model/invGroup';
import { InvItem } from '../model/invItem';
import { InvMetaGroup } from '../model/invMetaGroup';
import { InvMetaType } from '../model/invMetaType';
import { InvName } from '../model/invName';
import { InvPosition } from '../model/invPosition';
import { InvTrait } from '../model/invTrait';
import { InvType } from '../model/invType';
import { InvTypeMaterial } from '../model/invTypeMaterial';
import { InvTypeReaction } from '../model/invTypeReaction';
import { InvUniqueName } from '../model/invUniqueName';
import { InvVolume } from '../model/invVolume';
import { ServiceError } from '../model/serviceError';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class SDEInventoryService {

    protected basePath = 'https://evekit-sde.orbital.enterprises/20180713/api/ws/v20180713';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Get categories
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param categoryID Category ID selector
     * @param categoryName Category name selector
     * @param iconID Icon ID selector
     * @param published Published flag selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCategories(contid?: number, maxresults?: number, categoryID?: string, categoryName?: string, iconID?: string, published?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InvCategory>>;
    public getCategories(contid?: number, maxresults?: number, categoryID?: string, categoryName?: string, iconID?: string, published?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InvCategory>>>;
    public getCategories(contid?: number, maxresults?: number, categoryID?: string, categoryName?: string, iconID?: string, published?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InvCategory>>>;
    public getCategories(contid?: number, maxresults?: number, categoryID?: string, categoryName?: string, iconID?: string, published?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (categoryID !== undefined) {
            queryParameters = queryParameters.set('categoryID', <any>categoryID);
        }
        if (categoryName !== undefined) {
            queryParameters = queryParameters.set('categoryName', <any>categoryName);
        }
        if (iconID !== undefined) {
            queryParameters = queryParameters.set('iconID', <any>iconID);
        }
        if (published !== undefined) {
            queryParameters = queryParameters.set('published', <any>published);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<InvCategory>>(`${this.basePath}/inv/category`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get contraband types
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param factionID Faction ID selector
     * @param typeID Type ID selector
     * @param attackMinSec Attack minimum security level selector
     * @param confiscateMinSec Confiscation minimum security level selector
     * @param fineByValue Fine by value selector
     * @param standingLoss Standing loss selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getContrabandTypes(contid?: number, maxresults?: number, factionID?: string, typeID?: string, attackMinSec?: string, confiscateMinSec?: string, fineByValue?: string, standingLoss?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InvContrabandType>>;
    public getContrabandTypes(contid?: number, maxresults?: number, factionID?: string, typeID?: string, attackMinSec?: string, confiscateMinSec?: string, fineByValue?: string, standingLoss?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InvContrabandType>>>;
    public getContrabandTypes(contid?: number, maxresults?: number, factionID?: string, typeID?: string, attackMinSec?: string, confiscateMinSec?: string, fineByValue?: string, standingLoss?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InvContrabandType>>>;
    public getContrabandTypes(contid?: number, maxresults?: number, factionID?: string, typeID?: string, attackMinSec?: string, confiscateMinSec?: string, fineByValue?: string, standingLoss?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (factionID !== undefined) {
            queryParameters = queryParameters.set('factionID', <any>factionID);
        }
        if (typeID !== undefined) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (attackMinSec !== undefined) {
            queryParameters = queryParameters.set('attackMinSec', <any>attackMinSec);
        }
        if (confiscateMinSec !== undefined) {
            queryParameters = queryParameters.set('confiscateMinSec', <any>confiscateMinSec);
        }
        if (fineByValue !== undefined) {
            queryParameters = queryParameters.set('fineByValue', <any>fineByValue);
        }
        if (standingLoss !== undefined) {
            queryParameters = queryParameters.set('standingLoss', <any>standingLoss);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<InvContrabandType>>(`${this.basePath}/inv/contraband_type`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get control tower resource purposes
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param purpose Purpose selector
     * @param purposeText Purpose text selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getControlTowerResourcePurposes(contid?: number, maxresults?: number, purpose?: string, purposeText?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InvControlTowerResourcePurpose>>;
    public getControlTowerResourcePurposes(contid?: number, maxresults?: number, purpose?: string, purposeText?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InvControlTowerResourcePurpose>>>;
    public getControlTowerResourcePurposes(contid?: number, maxresults?: number, purpose?: string, purposeText?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InvControlTowerResourcePurpose>>>;
    public getControlTowerResourcePurposes(contid?: number, maxresults?: number, purpose?: string, purposeText?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (purpose !== undefined) {
            queryParameters = queryParameters.set('purpose', <any>purpose);
        }
        if (purposeText !== undefined) {
            queryParameters = queryParameters.set('purposeText', <any>purposeText);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<InvControlTowerResourcePurpose>>(`${this.basePath}/inv/control_tower_resource_purpose`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get control tower resources
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param controlTowerTypeID Control tower type ID selector
     * @param resourceTypeID Resource type ID selector
     * @param factionID Faction ID selector
     * @param minSecurityLevel Minimum security level selector
     * @param purpose Purpose selector
     * @param quantity Quantity selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getControlTowerResources(contid?: number, maxresults?: number, controlTowerTypeID?: string, resourceTypeID?: string, factionID?: string, minSecurityLevel?: string, purpose?: string, quantity?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InvControlTowerResource>>;
    public getControlTowerResources(contid?: number, maxresults?: number, controlTowerTypeID?: string, resourceTypeID?: string, factionID?: string, minSecurityLevel?: string, purpose?: string, quantity?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InvControlTowerResource>>>;
    public getControlTowerResources(contid?: number, maxresults?: number, controlTowerTypeID?: string, resourceTypeID?: string, factionID?: string, minSecurityLevel?: string, purpose?: string, quantity?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InvControlTowerResource>>>;
    public getControlTowerResources(contid?: number, maxresults?: number, controlTowerTypeID?: string, resourceTypeID?: string, factionID?: string, minSecurityLevel?: string, purpose?: string, quantity?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (controlTowerTypeID !== undefined) {
            queryParameters = queryParameters.set('controlTowerTypeID', <any>controlTowerTypeID);
        }
        if (resourceTypeID !== undefined) {
            queryParameters = queryParameters.set('resourceTypeID', <any>resourceTypeID);
        }
        if (factionID !== undefined) {
            queryParameters = queryParameters.set('factionID', <any>factionID);
        }
        if (minSecurityLevel !== undefined) {
            queryParameters = queryParameters.set('minSecurityLevel', <any>minSecurityLevel);
        }
        if (purpose !== undefined) {
            queryParameters = queryParameters.set('purpose', <any>purpose);
        }
        if (quantity !== undefined) {
            queryParameters = queryParameters.set('quantity', <any>quantity);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<InvControlTowerResource>>(`${this.basePath}/inv/control_tower_resource`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get flags
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param flagID Flag ID selector
     * @param flagName Flag name selector
     * @param flagText Flag text selector
     * @param orderID Order ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFlags(contid?: number, maxresults?: number, flagID?: string, flagName?: string, flagText?: string, orderID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InvFlag>>;
    public getFlags(contid?: number, maxresults?: number, flagID?: string, flagName?: string, flagText?: string, orderID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InvFlag>>>;
    public getFlags(contid?: number, maxresults?: number, flagID?: string, flagName?: string, flagText?: string, orderID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InvFlag>>>;
    public getFlags(contid?: number, maxresults?: number, flagID?: string, flagName?: string, flagText?: string, orderID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (flagID !== undefined) {
            queryParameters = queryParameters.set('flagID', <any>flagID);
        }
        if (flagName !== undefined) {
            queryParameters = queryParameters.set('flagName', <any>flagName);
        }
        if (flagText !== undefined) {
            queryParameters = queryParameters.set('flagText', <any>flagText);
        }
        if (orderID !== undefined) {
            queryParameters = queryParameters.set('orderID', <any>orderID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<InvFlag>>(`${this.basePath}/inv/flag`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get groups
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param groupID Group ID selector
     * @param anchorable Anchorable flag selector
     * @param anchored Anchored flag selector
     * @param categoryID Category ID selector
     * @param fittableNonSingleton Fittable non-singleton flag selector
     * @param groupName Group name selector
     * @param iconID Icon ID selector
     * @param published Published flag selector
     * @param useBasePrice Use base price selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getGroups(contid?: number, maxresults?: number, groupID?: string, anchorable?: string, anchored?: string, categoryID?: string, fittableNonSingleton?: string, groupName?: string, iconID?: string, published?: string, useBasePrice?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InvGroup>>;
    public getGroups(contid?: number, maxresults?: number, groupID?: string, anchorable?: string, anchored?: string, categoryID?: string, fittableNonSingleton?: string, groupName?: string, iconID?: string, published?: string, useBasePrice?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InvGroup>>>;
    public getGroups(contid?: number, maxresults?: number, groupID?: string, anchorable?: string, anchored?: string, categoryID?: string, fittableNonSingleton?: string, groupName?: string, iconID?: string, published?: string, useBasePrice?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InvGroup>>>;
    public getGroups(contid?: number, maxresults?: number, groupID?: string, anchorable?: string, anchored?: string, categoryID?: string, fittableNonSingleton?: string, groupName?: string, iconID?: string, published?: string, useBasePrice?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (groupID !== undefined) {
            queryParameters = queryParameters.set('groupID', <any>groupID);
        }
        if (anchorable !== undefined) {
            queryParameters = queryParameters.set('anchorable', <any>anchorable);
        }
        if (anchored !== undefined) {
            queryParameters = queryParameters.set('anchored', <any>anchored);
        }
        if (categoryID !== undefined) {
            queryParameters = queryParameters.set('categoryID', <any>categoryID);
        }
        if (fittableNonSingleton !== undefined) {
            queryParameters = queryParameters.set('fittableNonSingleton', <any>fittableNonSingleton);
        }
        if (groupName !== undefined) {
            queryParameters = queryParameters.set('groupName', <any>groupName);
        }
        if (iconID !== undefined) {
            queryParameters = queryParameters.set('iconID', <any>iconID);
        }
        if (published !== undefined) {
            queryParameters = queryParameters.set('published', <any>published);
        }
        if (useBasePrice !== undefined) {
            queryParameters = queryParameters.set('useBasePrice', <any>useBasePrice);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<InvGroup>>(`${this.basePath}/inv/group`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get items
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param itemID Item ID selector
     * @param flagID Flag ID selector
     * @param locationID Location ID selector
     * @param ownerID Owner ID selector
     * @param quantity Quantity selector
     * @param typeID Type ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getItems(contid?: number, maxresults?: number, itemID?: string, flagID?: string, locationID?: string, ownerID?: string, quantity?: string, typeID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InvItem>>;
    public getItems(contid?: number, maxresults?: number, itemID?: string, flagID?: string, locationID?: string, ownerID?: string, quantity?: string, typeID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InvItem>>>;
    public getItems(contid?: number, maxresults?: number, itemID?: string, flagID?: string, locationID?: string, ownerID?: string, quantity?: string, typeID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InvItem>>>;
    public getItems(contid?: number, maxresults?: number, itemID?: string, flagID?: string, locationID?: string, ownerID?: string, quantity?: string, typeID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (itemID !== undefined) {
            queryParameters = queryParameters.set('itemID', <any>itemID);
        }
        if (flagID !== undefined) {
            queryParameters = queryParameters.set('flagID', <any>flagID);
        }
        if (locationID !== undefined) {
            queryParameters = queryParameters.set('locationID', <any>locationID);
        }
        if (ownerID !== undefined) {
            queryParameters = queryParameters.set('ownerID', <any>ownerID);
        }
        if (quantity !== undefined) {
            queryParameters = queryParameters.set('quantity', <any>quantity);
        }
        if (typeID !== undefined) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<InvItem>>(`${this.basePath}/inv/item`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get meta groups
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param metaGroupID Meta group ID selector
     * @param description Description text selector
     * @param iconID Icon ID selector
     * @param metaGroupName Meta group name selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMetaGroups(contid?: number, maxresults?: number, metaGroupID?: string, description?: string, iconID?: string, metaGroupName?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InvMetaGroup>>;
    public getMetaGroups(contid?: number, maxresults?: number, metaGroupID?: string, description?: string, iconID?: string, metaGroupName?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InvMetaGroup>>>;
    public getMetaGroups(contid?: number, maxresults?: number, metaGroupID?: string, description?: string, iconID?: string, metaGroupName?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InvMetaGroup>>>;
    public getMetaGroups(contid?: number, maxresults?: number, metaGroupID?: string, description?: string, iconID?: string, metaGroupName?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (metaGroupID !== undefined) {
            queryParameters = queryParameters.set('metaGroupID', <any>metaGroupID);
        }
        if (description !== undefined) {
            queryParameters = queryParameters.set('description', <any>description);
        }
        if (iconID !== undefined) {
            queryParameters = queryParameters.set('iconID', <any>iconID);
        }
        if (metaGroupName !== undefined) {
            queryParameters = queryParameters.set('metaGroupName', <any>metaGroupName);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<InvMetaGroup>>(`${this.basePath}/inv/meta_group`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get meta types
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param typeID Type ID selector
     * @param metaGroupID Meta group ID selector
     * @param parentTypeID Parent type ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMetaTypes(contid?: number, maxresults?: number, typeID?: string, metaGroupID?: string, parentTypeID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InvMetaType>>;
    public getMetaTypes(contid?: number, maxresults?: number, typeID?: string, metaGroupID?: string, parentTypeID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InvMetaType>>>;
    public getMetaTypes(contid?: number, maxresults?: number, typeID?: string, metaGroupID?: string, parentTypeID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InvMetaType>>>;
    public getMetaTypes(contid?: number, maxresults?: number, typeID?: string, metaGroupID?: string, parentTypeID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (typeID !== undefined) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (metaGroupID !== undefined) {
            queryParameters = queryParameters.set('metaGroupID', <any>metaGroupID);
        }
        if (parentTypeID !== undefined) {
            queryParameters = queryParameters.set('parentTypeID', <any>parentTypeID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<InvMetaType>>(`${this.basePath}/inv/meta_type`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get names
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param itemID Item ID selector
     * @param itemName Item name selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getNames(contid?: number, maxresults?: number, itemID?: string, itemName?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InvName>>;
    public getNames(contid?: number, maxresults?: number, itemID?: string, itemName?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InvName>>>;
    public getNames(contid?: number, maxresults?: number, itemID?: string, itemName?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InvName>>>;
    public getNames(contid?: number, maxresults?: number, itemID?: string, itemName?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (itemID !== undefined) {
            queryParameters = queryParameters.set('itemID', <any>itemID);
        }
        if (itemName !== undefined) {
            queryParameters = queryParameters.set('itemName', <any>itemName);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<InvName>>(`${this.basePath}/inv/name`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get positions
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param itemID Item ID selector
     * @param pitch Pitch selector
     * @param roll Roll selector
     * @param x X selector
     * @param y Y selector
     * @param yaw Yaw selector
     * @param z Z selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPositions(contid?: number, maxresults?: number, itemID?: string, pitch?: string, roll?: string, x?: string, y?: string, yaw?: string, z?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InvPosition>>;
    public getPositions(contid?: number, maxresults?: number, itemID?: string, pitch?: string, roll?: string, x?: string, y?: string, yaw?: string, z?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InvPosition>>>;
    public getPositions(contid?: number, maxresults?: number, itemID?: string, pitch?: string, roll?: string, x?: string, y?: string, yaw?: string, z?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InvPosition>>>;
    public getPositions(contid?: number, maxresults?: number, itemID?: string, pitch?: string, roll?: string, x?: string, y?: string, yaw?: string, z?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (itemID !== undefined) {
            queryParameters = queryParameters.set('itemID', <any>itemID);
        }
        if (pitch !== undefined) {
            queryParameters = queryParameters.set('pitch', <any>pitch);
        }
        if (roll !== undefined) {
            queryParameters = queryParameters.set('roll', <any>roll);
        }
        if (x !== undefined) {
            queryParameters = queryParameters.set('x', <any>x);
        }
        if (y !== undefined) {
            queryParameters = queryParameters.set('y', <any>y);
        }
        if (yaw !== undefined) {
            queryParameters = queryParameters.set('yaw', <any>yaw);
        }
        if (z !== undefined) {
            queryParameters = queryParameters.set('z', <any>z);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<InvPosition>>(`${this.basePath}/inv/position`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get traits
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param traitID Trait ID selector
     * @param typeID Trait ID selector
     * @param skillID Skill ID selector
     * @param bonus Bonus selector
     * @param bonusText Bonus text selector
     * @param unitID Unit ID selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTraits(contid?: number, maxresults?: number, traitID?: string, typeID?: string, skillID?: string, bonus?: string, bonusText?: string, unitID?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InvTrait>>;
    public getTraits(contid?: number, maxresults?: number, traitID?: string, typeID?: string, skillID?: string, bonus?: string, bonusText?: string, unitID?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InvTrait>>>;
    public getTraits(contid?: number, maxresults?: number, traitID?: string, typeID?: string, skillID?: string, bonus?: string, bonusText?: string, unitID?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InvTrait>>>;
    public getTraits(contid?: number, maxresults?: number, traitID?: string, typeID?: string, skillID?: string, bonus?: string, bonusText?: string, unitID?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (traitID !== undefined) {
            queryParameters = queryParameters.set('traitID', <any>traitID);
        }
        if (typeID !== undefined) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (skillID !== undefined) {
            queryParameters = queryParameters.set('skillID', <any>skillID);
        }
        if (bonus !== undefined) {
            queryParameters = queryParameters.set('bonus', <any>bonus);
        }
        if (bonusText !== undefined) {
            queryParameters = queryParameters.set('bonusText', <any>bonusText);
        }
        if (unitID !== undefined) {
            queryParameters = queryParameters.set('unitID', <any>unitID);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<InvTrait>>(`${this.basePath}/inv/trait`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get type materials
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param typeID Type ID selector
     * @param materialTypeID Material type ID selector
     * @param quantity Quantity selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTypeMaterials(contid?: number, maxresults?: number, typeID?: string, materialTypeID?: string, quantity?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InvTypeMaterial>>;
    public getTypeMaterials(contid?: number, maxresults?: number, typeID?: string, materialTypeID?: string, quantity?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InvTypeMaterial>>>;
    public getTypeMaterials(contid?: number, maxresults?: number, typeID?: string, materialTypeID?: string, quantity?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InvTypeMaterial>>>;
    public getTypeMaterials(contid?: number, maxresults?: number, typeID?: string, materialTypeID?: string, quantity?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (typeID !== undefined) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (materialTypeID !== undefined) {
            queryParameters = queryParameters.set('materialTypeID', <any>materialTypeID);
        }
        if (quantity !== undefined) {
            queryParameters = queryParameters.set('quantity', <any>quantity);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<InvTypeMaterial>>(`${this.basePath}/inv/type_material`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get type reactions
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param reactionTypeID Reaction type ID selector
     * @param input Input selector
     * @param typeID Type ID selector
     * @param quantity Quantity selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTypeReactions(contid?: number, maxresults?: number, reactionTypeID?: string, input?: string, typeID?: string, quantity?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InvTypeReaction>>;
    public getTypeReactions(contid?: number, maxresults?: number, reactionTypeID?: string, input?: string, typeID?: string, quantity?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InvTypeReaction>>>;
    public getTypeReactions(contid?: number, maxresults?: number, reactionTypeID?: string, input?: string, typeID?: string, quantity?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InvTypeReaction>>>;
    public getTypeReactions(contid?: number, maxresults?: number, reactionTypeID?: string, input?: string, typeID?: string, quantity?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (reactionTypeID !== undefined) {
            queryParameters = queryParameters.set('reactionTypeID', <any>reactionTypeID);
        }
        if (input !== undefined) {
            queryParameters = queryParameters.set('input', <any>input);
        }
        if (typeID !== undefined) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (quantity !== undefined) {
            queryParameters = queryParameters.set('quantity', <any>quantity);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<InvTypeReaction>>(`${this.basePath}/inv/type_reaction`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get types
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param typeID Type ID selector
     * @param basePrice Base price selector
     * @param capacity Capacity selector
     * @param chanceOfDuplicating Chance of duplicating selector
     * @param description Description text selector
     * @param graphicID Graphic ID selector
     * @param groupID Group ID selector
     * @param iconID Icon ID selector
     * @param marketGroupID Market group ID selector
     * @param mass Mass selector
     * @param portionSize Portion size selector
     * @param published Published flag selector
     * @param raceID Race ID selector
     * @param soundID Sound ID selector
     * @param typeName Type name selector
     * @param volume Volume selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTypes(contid?: number, maxresults?: number, typeID?: string, basePrice?: string, capacity?: string, chanceOfDuplicating?: string, description?: string, graphicID?: string, groupID?: string, iconID?: string, marketGroupID?: string, mass?: string, portionSize?: string, published?: string, raceID?: string, soundID?: string, typeName?: string, volume?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InvType>>;
    public getTypes(contid?: number, maxresults?: number, typeID?: string, basePrice?: string, capacity?: string, chanceOfDuplicating?: string, description?: string, graphicID?: string, groupID?: string, iconID?: string, marketGroupID?: string, mass?: string, portionSize?: string, published?: string, raceID?: string, soundID?: string, typeName?: string, volume?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InvType>>>;
    public getTypes(contid?: number, maxresults?: number, typeID?: string, basePrice?: string, capacity?: string, chanceOfDuplicating?: string, description?: string, graphicID?: string, groupID?: string, iconID?: string, marketGroupID?: string, mass?: string, portionSize?: string, published?: string, raceID?: string, soundID?: string, typeName?: string, volume?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InvType>>>;
    public getTypes(contid?: number, maxresults?: number, typeID?: string, basePrice?: string, capacity?: string, chanceOfDuplicating?: string, description?: string, graphicID?: string, groupID?: string, iconID?: string, marketGroupID?: string, mass?: string, portionSize?: string, published?: string, raceID?: string, soundID?: string, typeName?: string, volume?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (typeID !== undefined) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (basePrice !== undefined) {
            queryParameters = queryParameters.set('basePrice', <any>basePrice);
        }
        if (capacity !== undefined) {
            queryParameters = queryParameters.set('capacity', <any>capacity);
        }
        if (chanceOfDuplicating !== undefined) {
            queryParameters = queryParameters.set('chanceOfDuplicating', <any>chanceOfDuplicating);
        }
        if (description !== undefined) {
            queryParameters = queryParameters.set('description', <any>description);
        }
        if (graphicID !== undefined) {
            queryParameters = queryParameters.set('graphicID', <any>graphicID);
        }
        if (groupID !== undefined) {
            queryParameters = queryParameters.set('groupID', <any>groupID);
        }
        if (iconID !== undefined) {
            queryParameters = queryParameters.set('iconID', <any>iconID);
        }
        if (marketGroupID !== undefined) {
            queryParameters = queryParameters.set('marketGroupID', <any>marketGroupID);
        }
        if (mass !== undefined) {
            queryParameters = queryParameters.set('mass', <any>mass);
        }
        if (portionSize !== undefined) {
            queryParameters = queryParameters.set('portionSize', <any>portionSize);
        }
        if (published !== undefined) {
            queryParameters = queryParameters.set('published', <any>published);
        }
        if (raceID !== undefined) {
            queryParameters = queryParameters.set('raceID', <any>raceID);
        }
        if (soundID !== undefined) {
            queryParameters = queryParameters.set('soundID', <any>soundID);
        }
        if (typeName !== undefined) {
            queryParameters = queryParameters.set('typeName', <any>typeName);
        }
        if (volume !== undefined) {
            queryParameters = queryParameters.set('volume', <any>volume);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<InvType>>(`${this.basePath}/inv/type`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get unique names
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param itemID Item ID selector
     * @param groupID Group ID selector
     * @param itemName Item name selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniqueNames(contid?: number, maxresults?: number, itemID?: string, groupID?: string, itemName?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InvUniqueName>>;
    public getUniqueNames(contid?: number, maxresults?: number, itemID?: string, groupID?: string, itemName?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InvUniqueName>>>;
    public getUniqueNames(contid?: number, maxresults?: number, itemID?: string, groupID?: string, itemName?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InvUniqueName>>>;
    public getUniqueNames(contid?: number, maxresults?: number, itemID?: string, groupID?: string, itemName?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (itemID !== undefined) {
            queryParameters = queryParameters.set('itemID', <any>itemID);
        }
        if (groupID !== undefined) {
            queryParameters = queryParameters.set('groupID', <any>groupID);
        }
        if (itemName !== undefined) {
            queryParameters = queryParameters.set('itemName', <any>itemName);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<InvUniqueName>>(`${this.basePath}/inv/unique_name`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get type volumes
     * 
     * @param contid Continuation ID for paged results
     * @param maxresults Maximum number of results to retrieve
     * @param typeID Type ID selector
     * @param volume Volume selector
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getVolumes(contid?: number, maxresults?: number, typeID?: string, volume?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InvVolume>>;
    public getVolumes(contid?: number, maxresults?: number, typeID?: string, volume?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InvVolume>>>;
    public getVolumes(contid?: number, maxresults?: number, typeID?: string, volume?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InvVolume>>>;
    public getVolumes(contid?: number, maxresults?: number, typeID?: string, volume?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contid !== undefined) {
            queryParameters = queryParameters.set('contid', <any>contid);
        }
        if (maxresults !== undefined) {
            queryParameters = queryParameters.set('maxresults', <any>maxresults);
        }
        if (typeID !== undefined) {
            queryParameters = queryParameters.set('typeID', <any>typeID);
        }
        if (volume !== undefined) {
            queryParameters = queryParameters.set('volume', <any>volume);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<InvVolume>>(`${this.basePath}/inv/volume`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
